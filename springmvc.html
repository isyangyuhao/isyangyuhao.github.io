<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>杨宇昊的学习笔记-Spring MVC</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="format-detection" content="telephone=no">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <link rel="alternate icon" type="image/png" href="assets/i/favicon.png">
    <link rel="stylesheet" href="assets/css/amazeui.min.css"/>
    <!--Link Web Font-->
    <link href='//cdn.webfont.youziku.com/webfonts/nomal/21641/47115/58916519f629d80de474e740.css' rel='stylesheet' type='text/css' />
    <!--代码高亮highlight.js-->
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
    <script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>-->
    <!--Link Base Style-->
    <link rel="stylesheet" type="text/css" href="css/base.css">
    <link rel="stylesheet" type="text/css" href="css/page.css"/>
    <style type="text/css">
    </style>
</head>
<body>
<!--导航栏 [[-->
<header class="am-topbar" >
    <h1 class="am-topbar-brand css89d1c34bc5489">
        <a href="index.html" class="am-center" style="margin: 0 auto;">杨宇昊的学习笔记 <small>yangyuhao.org</small></a>
    </h1>
</header>
<!--导航栏 ]]-->
<div class="am-g am-g-fixed">
    <div class="am-u-md-9 am-u-md-push-3" id="pageContent">
        <div class="am-g">
            <div class="am-u-sm-11 am-u-sm-centered">
                <div class="am-cf am-article am-scrollable-horizontal">
                    <!--文章[[-->
                    <h3 id="page1">一. 概述与环境搭建</h3>
                    <ol>
                        <li>Spring MVC概述
                            <ul>
                                <li>Spring为展示层提供基于MVC设计理念的主流框架</li>
                                <li>Spring MVC通过一套MVC注解，让POJO成为处理请求的控制器，无需实现任何借口</li>
                                <li>支持REST风格的URL请求</li>
                                <li>采用松散耦合可插拔组件结构，比起其他MVC框架更具扩展新和灵活性</li>
                            </ul>
                        </li>
                        <li>环境搭建
                            <ul>
                                <li>加入需要的jar包：spring-beans.jar, spring-context.jar, spring-core.jar,
                                    spring-expression.jar,
                                    spring-web.jar, spring-webmvc.jar, commons-logging.jar
                                </li>
                                <li>在web.xml中配置DispatcherServlet
                                    <img src="photo/springmvc/mvc1.png" class="am-img-responsive">
                                </li>
                                <li>加入Spring MVC配置文件
                                    <img src="photo/springmvc/mvc2.png" class="am-img-responsive">
                                </li>
                                <li>编写处理请求的处理器
                                    <img src="photo/springmvc/mvc3.png" class="am-img-responsive">
                                </li>
                                <li>编写视图
                                    <br><code>&lt;a href="test">Test&lt;/a></code>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page2">二. 处理请求参数</h3>
                    <ol>
                        <li>@RequestMapping注解
                            <ul>
                                <li>使用@RequestMapping注解控制器指定可处理的URL请求</li>
                                <li>@RequestMapping注解在类定义处：提供初步的请求映射信息，相对于web应用的根目录</li>
                                <li>@RequestMapping注解在方法处：提供进一步细分的映射信息，相对于类定义处的url；若未在类定义处直接@RequestMapping则方法处标记的url相对于web应用的根目录
                                    <br>e.g.<pre>
@RequestMapping("/springmvc")
@Controller
public class SpringMVCTest {
    private static final String SUCCESS = "success";
    @RequestMapping("/testRequestMapping")
    public String testRequestMapping() {
        System.out.println("test Request Mapping ...");
        return SUCCESS;
    }
}</pre>
                                </li>
                                <li>DispatcherServlet拦截请求后，通过控制器@RequestMapping提供的映射信息确定请求所对应的处理</li>
                                <li>使用method属性指定请求方式
                                    <br>e.g.<pre>
@RequestMapping(value="testMethod", method=RequestMethod.POST)
public String testMethod() {
    System.out.println("test method ...");
    return SUCCESS;
}</pre>
                                </li>
                                <li>使用params和headers更加精确的映射请求，params和headers支持简单表达式
                                    <pre>
@RequestMapping(value="testParamsAndHeaders",
        params={"username", "age!=10"},
        headers={"Accept-Language=en-US,zh;q=0.8"})
public String testParamsAndHeaders() {
    System.out.println("test params and headers ...");
    return SUCCESS;
}</pre>
                                </li>
                                <li>支持Ant风格的URL
                                    <ul>
                                        <li>? : 匹配文件名的一个字符</li>
                                        <li>* : 匹配文件名中的任意字符</li>
                                        <li>** : 匹配多层路径</li>
                                    </ul>
e.g. <pre>
@RequestMapping("testAntPath/*/test")
    public String testAntPath() {
    System.out.println("test Ant Path ...");
    return SUCCESS;
}</pre>
                                </li>
                                <li>使用@PathVarialbe注解映射URL绑定的占位符
                                    <ul>
                                        <li>带占位符的URL是Spring3.0新增的特性</li>
                                        <li>通过@PathVariable可以将URL中占位符参数绑定到控制器处理方法参数中，URL中的{xxx}占位符可以通过@PathVariable("xxx")绑定到操作方法的参数表中的参数</li>
                                        <li>e.g.
                                            <pre>
@RequestMapping("testPathVariable/{id}")
public String testPathVariable(@PathVariable("id") Integer id) {
    System.out.println("test PathVariable ...");
    System.out.println("id is " + id);
    return SUCCESS;
}</pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>REST(Repersentational State Transfer) 资源表现层状态转化
                            <ul>
                                <li>资源：网络上的一个实体，或者说网络上的一个具体信息，每种资源对应一个特定的URI，可以通过URI访问</li>
                                <li>表现层：将资源具体呈现出来的形式</li>
                                <li>状态转化：客户端想要操作服务器，需要通过某种手段让服务器发生状态转化，而这种状态转化建立在表现层之上</li>
                                <li>HTTP协议中的四种操作方式
                                    <ul>
                                        <li>GET - 获取资源 (e.g. /order/1 GET : 得到id=1的order)</li>
                                        <li>POST - 新建资源 (e.g. /order POST : 添加order)</li>
                                        <li>PUT - 更新资源 (e.g. /order/1 PUT : 更新id=1的order)</li>
                                        <li>DELETE - 删除资源 (e.g. /order/1 DELETE : 删除id=1的order)</li>
                                    </ul>
                                </li>
                                <li>将POST请求转换为DELETE/PUT请求 - 配置HiddenHttpMethodFilter拦截器
                                    <img src="photo/springmvc/mvc4.png" class="am-img-responsive">
                                </li>
                                <li>在页面中提交请求
                                    <img src="photo/springmvc/mvc5.png" class="am-img-responsive">
                                </li>
                                <li>在控制器中处理请求
                                    <img src="photo/springmvc/mvc6.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>映射请求参数
                            <ul>
                                <li>请求处理方法签名
                                    <ul>
                                        <li>Spring MVC通过分析处理方法的签名，将HTTP请求信息绑定到处理方法的相应参数表中的参数</li>
                                        <li>使用@Pathvariable, @RequestParam, @RequestHeader注解将HTTP请求的信息绑定到相应的参数表中的参数中，并根据方法的返回值做出后续处理</li>
                                    </ul>
                                </li>
                                <li>使用@RequestParam绑定请求的参数值
                                    <ul>
                                        <li>@RequestParam的成员变量
                                            <ul>
                                                <li>value : 参数名</li>
                                                <li>required : 是否必须；默认为true，若不存在对应参数则抛出异常</li>
                                                <li>defaultValue : 默认值</li>
                                            </ul>
                                        </li>
                                        <li>e.g.
                                            <pre>
&lt;a href="springmvc/testRequestParam?username=yang&password=1234">test Request Param&lt;/a>
@RequestMapping(value="testRequestParam", method=RequestMethod.GET)
public String testRequestParams(@RequestParam(value="username") String username,
        @RequestParam(value="password") String password) {
    System.out.println("test Request Param , username is " + username + " password is " + password);
    return SUCCESS;
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>使用@RequestHeader绑定请求的相应头
                                    <ul>
                                        <li>请求头包括了若干属性，服务器可据此获知客户端的信息，通过@RequestHeader注解即可将请求头的属性值绑定到参数表中的参数中</li>
                                        <li>
                                            <pre>
@RequestMapping(value="/testRequestHeader")
public String testRequestHeader(@RequestHeader(value="Accept-Language") String language) {
    System.out.println("test Request Header , Language is " + language);
    return SUCCESS;
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>使用@CookieValue获取指定Cookie值
                                    <pre>
@RequestMapping(value="testCookieValue")
public String testCookieValue(@CookieValue("JSESSIONID") String sessionId) {
    System.out.println("test CookieValue , sessionId is " + sessionId);
    return SUCCESS;
}</pre>
                                </li>
                                <li>使用POJO作为参数
                                    <ul>
                                        <li>Spring MVC会按照请求参数名和POJO属性名进行自动匹配，自动为该对象填充属性值，支持级联属性</li>
                                        <li>e.g.
                                            <pre>
@RequestMapping(value="testPojo")
public String testPojo(User user) {
    System.out.println("test Pojo : " + user);
    return SUCCESS;
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>使用原生Servlet API接口
                                    <ul>
                                        <li>Spring MVC可以接受的Servlet API类型参数
                                            <ul>
                                                <li>HttpServletRequest</li>
                                                <li>HttpServletResponse</li>
                                                <li>HttpSession</li>
                                                <li>java.security.Principal</li>
                                                <li>Locale</li>
                                                <li>InputStream</li>
                                                <li>OutputStream</li>
                                                <li>Reader</li>
                                                <li>Writer</li>
                                            </ul>
                                        </li>
                                        <li>e.g.
                                            <pre>
@RequestMapping("testServeltApi")
public String testServletApi(HttpServletRequest request, HttpServletResponse response) {
    System.out.println("HttpServletRequest is " + request);
    System.out.println("HttpServletResponse is " + response);
    return SUCCESS;
}</pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>处理模型数据
                            <ul>
                                <li>ModelAndView
                                    <ul>
                                        <li>
                                            控制器的处理方法返回值是ModelAndView类型，其既包含视图信息又包含模型数据信息，SpringMVC会把ModelAndView中的model放到request域对象中
                                        </li>
                                        <li>添加模型数据信息
                                            <br><code>ModelAndView addObject(String attributeName, Object attributeValue)</code>
                                            <br><code>ModelAndView addAllObjcet(Map<String ?> modelMap)</code>
                                        </li>
                                        <li>添加视图信息
                                            <br><code>void setView(View view)</code>
                                            <br><code>void setViewName(String viewName)</code>
                                        </li>
                                        <li>e.g.
                                            <pre>
@RequestMapping("testModelAndView")
public ModelAndView testModelAndView() {
    String viewName = SUCCESS;
    ModelAndView modelAndView = new ModelAndView(viewName);
    modelAndView.addObject("time", new Date());
    return modelAndView;
}
${requestScope.time}  //在页面获取</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>Map
                                    <ul>
                                        <li>Spring MVC内部使用org.springframework.ui.Model接口存储模型数据</li>
                                        <li>具体步骤
                                            <ul>
                                                <li>Spring MVC在调用方法前会创建一个隐含的模型对象作为模型数据的存储数据</li>
                                                <li>如果方法的参数表中存在Map或Model,ModelMap类型，Spring MVC会将隐含模型的引用传递给参数表中的参数，在方法内开发者可以通过传入的模型对象访问到模型的所有数据，也可以像模型中添加新的属性数据</li>
                                            </ul>
                                        </li>
                                        <li>e.g.
                                            <pre>
@RequestMapping("testMap")
public String testMap(Map&lt;String, Object> requestMap) {
    requestMap.put("names", Arrays.asList("AAA", "BBB", "CCC"));
    return SUCCESS;
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>@SessionAttribute注解
                                    <ul>
                                        <li>在多个请求之间共用某个模型属性的数据，在控制器类上方添加@SessionAttribute注解，SpringMVC就会将对应的属性暂存到HttpSession中</li>
                                        <li>@SessionSttribute注解可以通过属性名指定需要放到会话中的属性，也可以通过属性类型来指定哪些属性放到Session之中</li>
                                        <li>e.g.
                                            <pre>
//将request中的user和字符串类型的变量放到Session之中
@SessionAttributes(value={"user"}, types={String.class})
@RequestMapping("/springmvc")
@Controller
public class SpringMVCTest {
    private static final String SUCCESS = "success";
    @RequestMapping("testSessionAttribute")
    public String testSessionAttributes(Map<String, Object> map) {
        User user = new User("yang", "1234", 20);
        map.put("user", user);
        map.put("names", "yang");
        return SUCCESS;
    }
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>@ModelAttribute注解
                                    <ul>
                                        <li>被@ModelAttribute注解的方法会在控制器每个方法执行之前被SpringMVC自动调用</li>
                                        <li>被@ModelAttribute注解修饰的目标方法POJO类型的入参，其value值功能如下
                                            <br>SpringMVC会使用value属性值在implicitModel中查找对应的对象，若存在则会直接放到入参中
                                            <br>SpringMVC会以value作为键，POJO作为值，存放到request中
                                        </li>
                                        <li>实现对象的部分属性修改
                                            <pre>
//test ModelAttribute
@ModelAttribute
public void getPerson(@RequestParam(value="id", required=false), Map&lt;String, Object> map) {
    if (id != null) {
        //模拟从数据库中查询数据
        Person per = new Person(1, "yang", 180, 20);
        map.put("person", per);
    }
}
@RequestMapping("testModelAttribute")
public String testModelAttribute(@ModelAttribute("person") Person person) {
    System.out.println("修改：" + person);
    return SUCCESS;
}</pre>
                                        </li>
                                        <li>运行流程分析
                                            <ul>
                                                <li>执行@ModelAttribute注解修饰的方法，从数据库中取出对象，将对象放到Map中</li>
                                                <li>SpringMVC从Map中取出对象，并把表单的请求参数赋给对象的对应属性</li>
                                                <li>SpringMVC把上述对象传入目标方法的参数</li>
                                            </ul>
                                        </li>
                                        <li>确认目标方法POJO类型入参的过程
                                            <ul>
                                                <li>确定Key
                                                    <br>若目标方法的POJO类型中没有使用@ModelAttribute作为修饰，则key为POJO类名的第一个字母小写
                                                    <br>若使用了@ModelAttribute作为修饰，则key为@ModelAttribute注解的value属性值
                                                </li>
                                                <li>在ImplicModel中查找key对应的对象，若存在，则作为入参
                                                    <br>若在@ModelAttribute标记的方法中，在Map保存过且key确定的一致则会获取到
                                                </li>
                                                <li>若在ImplicModel中没有对应的对象，则检查Handler是否存在使用@SessionAttributes注解修饰，若使用了该注解，且@SessionAttributes注解的value值中包含了key，则会从HttpSession中获取key所对应的value值，若存在则直接传入到目标方法的入参中，若不存在则抛出异常(解决方法：1.将@SessionAttribute注解value值与入参名不同，2.使用@ModelAttribute注解)</li>
                                                <li>若Handler没有标识@SessionAttributes注解或者@SessionAttributes注解的value值不包含key，则会通过反射创建POJO类型的参数，传入目标方法的参数</li>
                                                <li>SpringMVC会把key和value保存到ImplicModel中，进而保存到request中</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page3">三. 视图与视图解析器</h3>
                    <ol>
                        <li>视图解析器
                            <ul>
                                <li>
                                    请求处理方法执行后，返回ModelAndView对象；对于返回String,View或ModelMap等类型的处理方法，SpringMVC会在内部将他们装配成一个ModelAndView对象
                                </li>
                                <li>SpringMVC借助试图解析器(ViewResolver)得到最终的视图对象(View)，最终的视图可以是jsp，也可以是Excel,JFreeChat等各种形式</li>
                                <li>对于最终究竟采用哪种视图对象对模型进行渲染，处理器并不关心，处理器工作重点聚焦在生产模型数据的工作上，从而实现MVC充分解耦</li>
                            </ul>
                        </li>
                        <li>视图
                            <ul>
                                <li>视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给用户</li>
                                <li>为了实现视图模型和具体实现技术的解耦，Spring在org.springframework.web.servlet包中定义了一个高度抽象的View接口</li>
                                <li>视图对象由视图解析器负责实例化，由于视图是无状态的，所以它们不会存在线程安全</li>
                            </ul>
                        </li>
                        <li>InternalResourceViewResolver与jstlView
                            <ul>
                                <li>配置视图解析器
                                    <pre>
&lt;!-- 配置视图解析器 : 如何将handler方法返回值解析为实际的物理视图 -->
&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    &lt;property name="prefix" value="/WEB-INF/views/">&lt;/property>
    &lt;property name="suffix" value=".jsp">&lt;/property>
&lt;/bean></pre>
                                </li>
                                <li>若项目中使用了JSTL，则SpringMVC会自动把视图由InternalResourceView转换成JstlView</li>
                                <li>若使用JSTL的fmt标签，则需要在SpringMVC配置文件中配置国际化资源文件
                                    <pre>
&lt;!-- 配置国际化资源文件 -->
&lt;bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">
    &lt;property name="basename" value="i18n">&lt;/property>
&lt;/bean></pre>
                                </li>
                            </ul>
                        </li>
                        <li>mvc:view-controller
                            <ul>
                                <li>该标签用于配置直接转发的页面，无需经过Handler方法</li>
                                <li>使用mvc:annotation-driven，防止被直接转发的页面无法使用Handler</li>
                                <li>e.g.
                                    <pre>
&lt;mvc:view-controller path="/success" view-name="success"/>
&lt;mvc:annotation-driven>&lt;/mvc:annotation-driven></pre>
                                </li>
                            </ul>
                        </li>
                        <li>自定义视图
                            <ul>
                                <li>编写自定义视图类
                                    <pre>
@Component
public class HelloView implements View {
    //返回类型
    public String getContentType() {
        return "text/html";
    }
    //渲染视图
    public void render(Map&lt;String, ?> arg0, HttpServletRequest arg1,
            HttpServletResponse arg2) throws Exception {
        arg2.getWriter().println("hello view, time : " + new Date());
    }
}</pre>
                                </li>
                                <li>配置BeanNameViewResolver视图解析器
                                    <pre>
&lt;!-- 配置BeanNameViewResolver视图解析器：使用视图的名字解析视图 -->
&lt;!-- 通过order属性来定义视图的优先级，order值越小优先级别越高 -->
&lt;bean class="org.springframework.web.servlet.view.BeanNameViewResolver">
    &lt;property name="order" value="100">&lt;/property>
&lt;/bean></pre>
                                </li>
                            </ul>
                        </li>
                        <li>重定向操作
                            <ul>
                                <li>一般情况下，控制器方法返回的字符串类型会被当作逻辑视图名处理</li>
                                <li>如果返回的字符串带有"forward:"或者"redirect:"前缀时，SpringMVC会对他们进行特殊处理：
                                    <ul>
                                        <li>redirect:success.jsp : 重定向到success.jsp操作</li>
                                        <li>forward:success.jsp : 转发到success.jsp操作</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page4">四. 表单与静态资源</h3>
                    <ol>
                        <li>Spirng MVC表单标签
                            <ul>
                                <li>通过SpringMVC表单标签，可以实现将模型数据中的属性和HTML表单相绑定，以实现表单数据更便捷编辑和表单值回显</li>
                                <li>form标签
                                    <ul>
                                        <li>一般情况下 通过GET请求获取表单页面，通过POST提交表单页面，因此获取表单页面和提交表单页面的URL是相同的；
                                            只要满足最佳条件的契约，&lt;form:form>标签无需通过action属性指定表单提交的URL
                                        </li>
                                        <li>通过modelAttribute属性指定绑定的模型属性，若没有该属性，则默认从request域对象中读取command表单的bean，如果该属性也不存在则会发生错误</li>
                                    </ul>
                                </li>
                                <li>SpringMVC提供了多个表单组标签，如&lt;form:input/>, &lt;form:select/>等，用于绑定表单字段的属性值，其通用属性
                                    <ul>
                                        <li>path - 表单字段，对应html元素的name属性，支持级联属性</li>
                                        <li>htmlEscape - 是否对表单值得HTML特殊字符进行转换，默认为true</li>
                                        <li>cssClass - 表单组件对应的css样式类名</li>
                                        <li>cssErrorClass - 表单组件的数据存在错误时采用的css样式</li>
                                    </ul>
                                </li>
                                <li>form:input, form:password, form:hidden, form:textarea : 分别对应着表单的text, password, hidden, textarea标签</li>
                                <li>form:radiobutton:单选框组件标签，当表单bean对应的属性值和value值相等时，单选框被选中</li>
                                <li>form:radioButtons:单选框组标签，用于构造多个单个单选框
                                    <ul>
                                        <li>items - 可以是也给List, String[], Map</li>
                                        <li>itemValue - 指定radio的value值，可以是集合中bean的一个属性值</li>
                                        <li>itemLabel - 指定radil的label值</li>
                                        <li>delimiter - 多个单选框可以通过delimiter指定分隔符</li>
                                    </ul>
                                </li>
                                <li>form:checkbox:复选框组件，用于构造单个复选框</li>
                                <li>form:checkboxs:用于构造多个复选框，使用方式同radioButtons</li>
                                <li>form:select:用于构造下拉框组件，使用方式同radioButtons</li>
                                <li>form:option:下拉框选项组件标签，使用方式同form:radioButtons</li>
                                <li>form:errors:显示表单组件或数据校验所对应的错误
                                    <ul>
                                        <li>&lt;form:errors path="*" /> - 显示表单的所有错误</li>
                                        <li>&lt;form:errors path="user*" /> - 显示所有以user作为前缀的属性对应错误</li>
                                        <li>&lt;form:errors path="username"> - 显示特定表单属性的错误</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Spring MVC处理静态资源
                            <ul>
                                <li>问题
                                    <br>REST风格的URL资源不希望带.html和.do等后缀，若DispatcherServlet请求映射为/，则SpringMVC将捕获WEB容器的所有请求，包括静态资源的请求，SpringMVC会将其当成普通请求，因此找不到对应处理器导致404错误
                                </li>
                                <li>解决方案
                                    <br>在SpringMVC的配置文件中配置默认处理器 : &lt;mvc:default-servlet-handler/>的方式解决静态资源的问题
                                    <ul>
                                        <li>&lt;mvc:default-servlet-handler/>将在SpringMVC上下文中定义一个DefaultServletHttpRequestHandler，它会对进入进入DispathcerServlet的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由WEB应用服务器默认的Servlet进行处理，如果不是静态资源才由DispatcherServlet继续处理</li>
                                        <li>一般WEB服务器默认的Servlet名称都为default，若所使用的WEB服务器默认Servlet不是default，则需要通过default-servlet-name属性显式指定</li>
                                    </ul>
                                </li>
                                <li>e.g.
                                    <pre>
&lt;!-- 配置默认的Handler -->
&lt;mvc:default-servlet-handler/>
&lt;mvc:annotation-driven>&lt;/mvc:annotation-driven></pre>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page5">五. 数据绑定/类型转换/格式化/校验</h3>
                    <ol>
                        <li>数据绑定流程
                            <ul>
                                <li>Spring MVC主框架将ServletRequest对象及目标方法的入参实例传递给WebDataBinderFactory实例，创建DataBinder实例对象</li>
                                <li>DataBinder对象调用装配在Spring MVC上下文中的ConversionService组件进行数据类型转换，数据格式化的工作，将Servlet中的请求信息填充到入参对象中</li>
                                <li>调用Validator组件对已经绑定了请求信息的入参对象进行数据合法化校验，最终生成数据绑定结果BindingData对象</li>
                                <li>Spring MVC抽取BindingData中的入参对象和校验错误对象，将它们赋给处理方法的响应入参</li>
                            </ul>
                        </li>
                        <li>数据类型转换
                            <ul>
                                <li>Spring上下文中内建了很多个转换器，可以完成大多数Java类型的格式转换</li>
                                <li>自定义类型转换器的接口
                                    <ul>
                                        <li>ConversionService是Spring类型转换体系的核心接口</li>
                                        <li>可以利用ConversionServiceBeanFactory在Spring的IOC容器中定义一个ConversionService，Spring会自动识别出IOC中的ConversionService，并在Bean属性配置及SpringMVC处理方法入参绑定等场合使用它进行数据转换</li>
                                        <li>可以通过ConversionServiceBeanFactory的converters属性注册自定义类型转换器</li>
                                    </ul>
                                </li>
                                <li>Spring支持的类型转换器
                                    <br>Spring定义了3中类型转换器的接口，实现任意一个转换器接口都可以将自定义转换器注册到ConversionServiceBeanFactory中
                                    <ul>
                                        <li>Converter&lt;S, T> : 将S类型转化为T类型</li>
                                        <li>ConversionFactory : 将相同系列的同质Converter封装在一起，如果希望将一种类型的对象转换为另一种类型的对象及其子类对象，可以使用转换器工厂类</li>
                                        <li>GenericFactory : 会根据源类对象及目的类对象所在的宿主上下文信息进行类型转换</li>
                                    </ul>
                                </li>
                                <li>自定义类型转化器实例
                                    <ul>
                                        <li>需求：将"1-dept1"格式的字符串转换为Department对象
                                            <pre>
&lt;form action="testConverter" method="post">
    &lt;input type="text" name="department">
    &lt;button type="submit">String -> Department&lt;/button>
&lt;/form></pre>
                                        </li>
                                        <li>步骤1：在Handler中获取字符串，并以Department形式承载
                                            <pre>
@RequestMapping(value="testConverter")
public String testConverter(@RequestParam("department") Department department) {
    System.out.println("department : " + department);
    return "success";
}</pre>
                                        </li>
                                        <li>步骤2：创建自定义类型转换器
                                            <pre>
@Component
public class DepartmentConverter implements Converter&lt;String, Department> {
    @Override
    public Department convert(String arg0) {
        if (arg0 != null) {
        String [] values = arg0.split("-");
        if (values != null && values.length == 2) {
            Integer id = Integer.parseInt(values[0]);
            String departmentName = values[1];
            Department department = new Department(id, departmentName);
            System.out.println(arg0 + " --converter-- " + department);
            return department;
            }
        }
    return null;
    }
}</pre>
                                        </li>
                                        <li>步骤3：在配置文件中加入自定义类型转换器
                                            <pre>
&lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean">&lt;/mvc:annotation-driven>
&lt;!-- 配置ConversionService -->
&lt;bean id="conversionServiceFactoryBean"
      class="org.springframework.context.support.ConversionServiceFactoryBean">
    &lt;property name="converters">
        &lt;list>
            &lt;ref bean="departmentConverter">&lt;/ref>
        &lt;/list>
    &lt;/property>
&lt;/bean></pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>使用&lt;mvc:annotation-driver/>标签的作用
                            <ul>
                                <li>会自动注册RequestMappingHandlerMapping, RequestMappingHandlerAdapter,
                                    ExceptionHandlerResolver三个bean
                                </li>
                                <li>对以下提供支持
                                    <ul>
                                        <li>支持使用ConversionService实例对表单参数进行类型转换</li>
                                        <li>支持使用@NumberFormatannotation, @DateTimeFormat注解完成数据类型格式化</li>
                                        <li>支持使用@Valid注解对javaBean实例进行JSR303验证</li>
                                        <li>支持使用@RequestBody和@ResponseBody注解</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>@InitBinder注解
                            <ul>
                                <li>由@InitBinder注解标识的方法，可以对WebDataBinder对象进行初始化，WebDataBinder是DataBinder对象的子类，用于完成表单字段到JavaBean属性的绑定</li>
                                <li>@InitBinder注解标识的方法不可以有返回值，它的声明必须为void</li>
                                <li>@InitBinder注解标识的方法参数通常是WebDataBinder</li>
                                <li>e.g. 设置不被JavaBean映射的表单字段
                                    <pre>
@InitBinder
public void initBinder(WebDataBinder webDataBinder) {
    webDataBinder.setDisallowedFields("age");  //javaBean不会获取表单中的age字段
}</pre>
                                </li>
                            </ul>
                        </li>
                        <li>数据格式化
                            <ul>
                                <li>对属性对象的输入和输出进行格式化，从其本质上依然属于类型转换的范畴</li>
                                <li>
                                    Spring在格式化模块中定义了一个实现ConversionService的接口的FormattingConversionService实现类，该实现类扩展了GenericConversionService，既具有类型转换的功能，又具有格式化的功能
                                </li>
                                <li>
                                    FormattingConversionService拥有一个FormattingConversionServiceFactoryBean工厂类，后者用于在Spring上下文中构造前者
                                </li>
                                <li>FormattingConversionServiceFactoryBean内部注册了
                                    <ul>
                                        <li>NumberFormatAnnotationFormatterFactory - 支持对数字类型的属性使用@NumberFormat注解</li>
                                        <li>JodaDateTimeFormatAnnotationFormatterFactory - 支持对日期类型的属性使用@DateTimeFormat注解</li>
                                    </ul>
                                </li>
                                <li>装配了FormattingConversionServiceFactoryBean后，就可以在SpringMVC入参绑定及模型数据输出时使用注解驱动了
                                    &lt;mvc:annotation-driver/>默认创建了ConversionService的实例即FormattingConversionServiceFactoryBean</li>
                                <li>日期格式化
                                    <br>@DataTimeFormat注解可以对java.util.Date, java.util.Calender, java.long.Long进行标注
                                    <ul>
                                        <li>pattern属性：类型为字符串，指定解析/格式化后的数据模式，如"yyyy-MM-dd  hh:mm:ss"</li>
                                        <li>iso属性 ： 类型为DataTimeFormat.ISO，指定解析/格式化字段数据的ISO模式，包括以下4种
                                            <ul>
                                                <li>ISO.NONE(default) - 不使用格式化</li>
                                                <li>IOS.DATE - yyyy-MM-dd</li>
                                                <li>ISO.TIME - hh:mm:ss.SSSZ</li>
                                                <li>ISO.DATA_TIME yyyy-MM-dd hh:mm:ss.SSSZ</li>
                                            </ul>
                                        </li>
                                        <li>style属性：字符串类型，通常样式指定日期时间的格式，由两位数字组成，第一位表示日期的格式，第二位表示时间的格式；S代表段日期/时间格式，M代表中日期/时间格式，L代表长日期/时间格式，F代表完整日期/时间格式，-代表忽略日期/时间格式</li>
                                    </ul>
                                </li>
                                <li>数值格式化
                                    <br>@NumberFormat注解可以对类似数字类型的属性进行标注，它拥有两个互斥属性
                                    <ul>
                                        <li>pattern属性：类型为字符串，自定义样式，如"#,###,###.#"</li>
                                        <li>style属性：类型为NumberFormatStyle，用于指定样式类型，包括三种：Style.NUMBER(正常数字类型)，Style.CURRENCY(货币类型)，Style.PERCENT(百分数类型)</li>
                                    </ul>
                                </li>
                                <li>数据格式化实例
                                    <ul>
                                        <li>步骤1：在对应实体类中需要进行数据格式化的属性前加上对应格式化注解，并传入相关参数
                                            <pre>
public class Person {
    private String id;
    @DateTimeFormat(pattern="yyyy-MM-dd")
    private Date birth;
    @NumberFormat(pattern="#,###,###.#")
    private Double salary;
}</pre>
                                        </li>
                                        <li>步骤2 ：在对应Handler中接受表单传入的参数
                                            <pre>
@RequestMapping(value="testFormat")
    public String testFormat(Person person) {
    System.out.println(person);
    return "success";
}</pre>
                                        </li>
                                        <li>步骤3：在配置文件中添加数值格式化和类型转换器对应的JavaBean
                                            <pre>
&lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean">&lt;/mvc:annotation-driven>
                                    <!-- 配置ConversionService -->
&lt;bean id="conversionServiceFactoryBean"
      class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
    &lt;property name="converters">
        &lt;list>
            &lt;ref bean="departmentConverter">&lt;/ref>
        &lt;/list>
    &lt;/property>
&lt;/bean></pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>处理数据格式化错误
                                    <pre>
@RequestMapping(value="testFormat")
public String testFormat(Person person, BindingResult result) {
    //处理数据格式化错误
    if (result.getErrorCount() > 0) {
        System.out.println("format error!");
        for (FieldError error : result.getFieldErrors()) {
            System.out.println(error.getField() + " : " + error.getDefaultMessage());
        }
    }
    System.out.println(person);
    return "success"
}</pre>
                                </li>
                            </ul>
                        </li>
                        <li>JSR303数据校验
                            <ul>
                                <li>JSR303
                                    <ul>
                                        <li>JSR303是java为Bean数据合法性校验提供的标准框架，它已经包含在JavaEE6.0中</li>
                                        <li>JSR303通过在Bean属性上标注类似于@NotNull，@Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证</li>
                                        <li>JSR303提供的注解
                                            <img src="photo/springmvc/mvc7.png" class="am-img-responsive">
                                        </li>
                                    </ul>
                                </li>
                                <li>Hibernate Validator扩展注解
                                    <br>Hibernate Validator 是JSR303的一个参考实现，除了支持所有标准的校验注解外，还支持以下的扩展注解
                                    <img src="photo/springmvc/mvc8.png" class="am-img-responsive">
                                </li>
                                <li>SpringMVC数据校验
                                    <ul>
                                        <li>Spring4.0拥有自己独立的数据校验框架，同时支持JSR303标准的校验框架</li>
                                        <li>SpringMVC在进行数据绑定时，可以同时调用校验框架完成数据校验工作，在SpringMVC中，可以通过注解驱动的方式进行数据校验</li>
                                        <li>Spring的LocationValidatorFactoryBean既实现了Spring的Validator接口，也实现了JSR303的Validator接口，只要在Spring容器中定义一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的Bean中</li>
                                        <li>Spring本身没有提供JSR303的实现，所以必须将JSR303的实现者的jar包加入
                                            <br>将Hibernate-Validator.Final中dist下的jar包和require文件夹中的jar包导入
                                        </li>
                                        <li>在JavaBean中加入对应的验证注解</li>
                                        <li>&lt;mvc:annotation-driven/>会默认装配好一个LocalValidatorFactoryBean，通过在Handler处理方法的入参上标注@Valid注解即可让SpringMVC在完成数据绑定后调用验证框架的校验规则实施校验</li>
                                        <li>数据校验发生错误后会将错误信息存放到BindingResult中</li>
                                    </ul>
                                </li>
                                <li>校验实例
                                    <ul>
                                        <li>步骤1：在实体类中将需要验证的属性加上验证注解
                                            <pre>
public class Person {
    private String id;
    @Past
    @DateTimeFormat(pattern="yyyy-MM-dd")
    private Date birth;
    @NumberFormat(pattern="#,###,###.#")
    private Double salary;
    //对应的getter & setter
}</pre>
                                        </li>
                                        <li>步骤2：在Handler中将需要验证的实体类入参加上@Valid注解和处理错误的BindingResult，并处理发生的错误
                                            <pre>
@RequestMapping(value="testFormat")
public String testFormat(@Valid Person person, BindingResult result) {
    //处理发生的错误
    if (result.getErrorCount() > 0) {
        System.out.println("format error!");
        for (FieldError error : result.getFieldErrors()) {
            System.out.println(error.getField() + " : " + error.getDefaultMessage());
        }
        return "error";  //发生错误跳转的页面
    }
    System.out.println(person);
    return "success";
}</pre>
                                        </li>
                                        <li>步骤3：在配置文件中加入&lt;mvc:annotation-driven/></li>
                                    </ul>
                                </li>
                                <li>处理错误信息
                                    <ul>
                                        <li>显示错误消息
                                            <br>使用&lt;form:error spath=“”>标签将指定属性的错误信息显示出来
                                        </li>
                                        <li>定制错误消息以及错误信息国际化
                                            <ul>
                                                <li>每个数据在数据绑定和数据校验发生错误时，会生成一个FieldError对象</li>
                                                <li>当一个属性校验失败后，校验框架会为该属性生成4个消息代码，这些代码以校验注解类名为前缀，结合modleAttribute，属性名，以及属性类型名生成多个对应的消息代码
                                                    <br>e.g. User类中的password属性标注了@Pattern，当该值不满足@pattern所制定的规则时，就会产生以下4个错误代码
                                                    Pattern.user.password, Pattern.password, Pattern.java.lang.String, Pattern
                                                </li>
                                                <li>当使用SpringMVC标签显示错误消息时，SpringMVC会查看web上下问是否装配了对应国际化消息，如果没有则显示默认信息，若果存在则使用国家化资源信息</li>
                                            </ul>
                                        </li>
                                        <li>其他资源国际化前缀
                                            <ul>
                                                <li>required：必要参数不存在的时候发生的错误</li>
                                                <li>typeMismatch：在数据绑定时，发生数据类型不匹配的错误</li>
                                                <li>methodInvocation：SpringMVC在调用处理方法时发生的错误</li>
                                            </ul>
                                        </li>
                                        <li>e.g. 定制资源国际化错误提示信息
                                            <ul>
                                                <li>步骤1：在配置文件中配置资源国际化文件
                                                    <pre>
&lt;bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">
    &lt;property name="basename" value="i18n">&lt;/property>
&lt;/bean></pre>
                                                </li>
                                                <li>步骤2：在i18n.properties中按照对应规则填写提示信息
                                                    <br>Past.person.birth = xxx
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page6">六. 处理JSON/国际化/文件上传/自定义拦截器</h3>
                    <ul>
                        <li>处理JSON
                            <ul>
                                <li>处理JSON步骤
                                    <ul>
                                        <li>加入jackson-annotations.jar, jackson-core.jar, jackson-databind.jar</li>
                                        <li>编写目标处理器，返回JSON对应的对象或集合</li>
                                        <li>使用@ResponseBody注解标识方法</li>
                                    </ul>
                                </li>
                                <li>处理JSON实例
                                    <ul>
                                        <li>发送AJAX请求
                                            <pre>
$(function() {
    $("#json").click(function() {
    var url = this.href;c
    var args = {};
    $.post(url, args, function(data) {
        for (var i = 0; i < data.length; ++i) {
            var id = data[i].id;
            var departmentName = data[i].departmentName;
            alert(id + " / " + departmentName);
            }
        });
        return false;
    });
})</pre>
                                        </li>
                                        <li>处理AJAX请求
                                            <pre>
@ResponseBody
@RequestMapping(value="testJson")
    public List&lt;Department> testJson() {
    List&lt;Department> departments = new ArrayList<>();
    departments.add(new Department(1, "dept-1"));
    departments.add(new Department(2, "dept-2"));
    return departments;
}
                                            </pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>HttpMessageConverter&lt;T>
                                    <ul>
                                        <li>HttpMessageConverter
                                            &lt;T>是Spring3.0新增添的接口，负责将请求信息转换成一个对象(类型为T)，将对象输出为响应信息
                                        </li>
                                        <li>HttpMessageConverter&lt;T>接口定义的方法
                                            <ul>
                                                <li>Boolean canRead(Class&lt;?> clazz, MediaType
                                                    mediaType)：指定转换器可以读取的对象类型，即转换器是否可将请求信息转为clazz类型的对象，同时支持指定MIME类型(text/html,
                                                    application/json等)
                                                </li>
                                                <li>Boolean canWrite(Class&lt;?> clazz, MediaType
                                                    mediaType)：指定转换器是否可将clazz类型的对象写到响应流中，响应流支持的媒体类型在MedaiType中定义
                                                </li>
                                                <li>List&lt;MediaType> getSupportMediaTypes()：获取该转换器支持的媒体类型</li>
                                                <li>T read(Class&lt;? extends T> clazz, HttpInputMessage inputMessage)：将请求信息流转换为T类型的对象</li>
                                                <li>void write(T t, MediaType contentType, HttpOutputMessage outputMessage)：将T类型的对象写到响应流中，同时指定响应的媒体类型为contentType</li>
                                            </ul>
                                        </li>
                                        <li>运行流程分析
                                            请求报文 -> HttpInputMessage -> HttpMessageConverter -> Object ->
                                            SpringMVC -> Object -> HttpMessageConverter -> HttpOutputMessage -> 响应报文
                                        </li>
                                        <li>使用HttpMessageConverter&lt;T>
                                            <ul>
                                                <li>使用HttpMessageConverter
                                                    &lt;T>将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的相应信息，Spring提供了两种途径
                                                    <ul>
                                                        <li>使用@RequestBody / @ResponseBody对处理方法进行标识</li>
                                                        <li>使用HttpEntity<T> / ResponseEntity<T>作为处理方法的入参或者返回值</li>
                                                    </ul>
                                                </li>
                                                <li>当控制器处理方法使用到@RequestBody / @ResponseBody或HttpEntity<T> / ResponseEntity<T>时，Spring首先根据请求头或响应头的Accept属性选择匹配的HttpMessageConverter，进而根据参数类型或者泛型类型的过滤的到匹配的HttpMessageConverter，若找不到可用的HttpMessageConverter将会报错</li>
                                                <li>@RequestBody和@ResponseBody不需要成对出现</li>
                                                <li>使用@ResponseBody和@RequestBody实例-文件上传(无法获取上传的数据流，开发中不使用此方法)
                                                    <ul>
                                                        <li>文件上传jsp部分
                                                            <pre>
&lt;form action="testHttpMessageConverter" method="post" enctype="multipart/form-data">
    File : &lt;input type="file" name="file">
    Desc : &lt;input type="text" name="desc">
    &lt;input type="submit" value="submit">
&lt;/form></pre>
                                                        </li>
                                                        <li>控制器处理方法
@ResponseBody
@RequestMapping(value="testHttpMessageConverter")
    public String testHttpMessageConverter(@RequestBody String body) {
    System.out.println(body);
    return "Test HttpMessageConverter -> " + new Date();
}</li>
                                                    </ul>
                                                </li>
                                                <li>使用ResponseEntity&lt;T>实例-文件下载
                                                    <pre>
@RequestMapping("testResponseEntity")
public ResponseEntity&lt;byte []> testResponseEntity(HttpSession session) throws IOException {
    ServletContext servletContext = session.getServletContext();
    InputStream inputStream = servletContext.getResourceAsStream("/files/test.txt");
    byte [] body = new byte[inputStream.available()];
    inputStream.read(body);
    HttpHeaders headers = new HttpHeaders();
    HttpStatus statusCode = HttpStatus.OK;
    headers.add("Content-Disposition", "attachment;filename=test.txt");
    ResponseEntity&lt;byte []> responseEntity = new ResponseEntity&lt;byte[]>(body, headers, statusCode);
    return responseEntity;
}</pre>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>资源国际化
                            <ul>
                                <li>提供国际化功能
                                    <ul>
                                        <li>在页面上通过浏览器语言设置的情况对文本，事件，数值进行本地化处理</li>
                                        <li>在bean中获取国际化资源文件local对应的消息</li>
                                        <li>通过超链接切换local，而不再依赖于浏览器的语言设定</li>
                                    </ul>
                                </li>
                                <li>解决方案
                                    <ul>
                                        <li>通过JSTL的fmt标签实现页面内容的国际化</li>
                                        <li>在bean中注入ResourceBundleMessageSource的实例，使用其对应的getMessage方法即可获取bean中对应的消息</li>
                                        <li>配置LocalResolver和LocalChangeInterceptor实现超链接切换local</li>
                                    </ul>
                                </li>
                                <li>国际化实例
                                    <ul>
                                        <li>配置国际化资源bean
                                            <pre>
&lt;bean id="messageSource"
      class="org.springframework.context.support.ResourceBundleMessageSource">
    &lt;property name="basename" value="i18n">&lt;/property>
&lt;/bean></pre>
                                        </li>
                                        <li>配置国际化资源文件
                                            <pre>
#i18n.properties
    i18n.username = Username
    i18n.password = Password
#i18n_en_US.properties
    i18n.username = Username
    i18n.password = Password
#i18n2_zh_CN.properties
    i18n.username = \u7528\u6237\u540D
i18n.password = \u5BC6\u7801</pre>
                                        </li>
                                        <li>在页面中获取国际化资源
                                            <pre>
&lt;fmt:message key="i18n.username">&lt;/fmt:message>
&lt;fmt:message key="i18n.password">&lt;/fmt:message></pre>
                                        </li>
                                        <li>在Handler中获取国际化资源
                                            <pre>
@Autowired
private ResourceBundleMessageSource messageSource;
@RequestMapping(value="i18n")
public String i18nView(Locale locale) {
    String username = messageSource.getMessage("i18n.username", null, locale);
    String password = messageSource.getMessage("i18n.password", null, locale);
    return "i18n";
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>通过超链接修改Locale
                                    <ul>
                                        <li>配置SessionLocalResolver
                                            <pre>
&lt;bean id="localeResolver"
      class="org.springframework.web.servlet.i18n.SessionLocaleResolver">
&lt;/bean>
                                            </pre>
                                        </li>
                                        <li>配置LocalChangeInterceptor
                                            <pre>
&lt;!-- 配置LocalChangeInterceptor -->
&lt;mvc:interceptors> 
    &lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">&lt;/bean>
&lt;/mvc:interceptors></pre>
                                        </li>
                                        <li>在页面中定义超链接
                                            <pre>
&lt;a href="i18n?locale=zh_CN">中文&lt;/a>
&lt;a href="i18n?locale=en_US">英文&lt;/a></pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>文件上传
                            <ul>
                                <li>SpringMVC为文件上传提供了直接的支持，这种支持通过即插即用的MultiparResolver实现的，Spring用Jakarta Commons
                                    FileUpload技术实现了一个MultipartResolver实现类-CommonsMultipartResovler
                                </li>
                                <li>
                                    SpringMVC上下文中默认没有装配MultipartResovler，因此默认情况下爱不能处理文件的上传工作，如果需要上传工作则需要配置MultipartResolver
                                </li>
                                <li>文件上传实例
                                    <ul>
                                        <li>配置MultipartResolver
                                            <pre>
&lt;bean id="multipartResolver"
      class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    &lt;property name="defaultEncoding" value="utf-8">&lt;/property>
    &lt;property name="maxUploadSize" value="1024000">&lt;/property>
&lt;/bean>
                                            </pre>
                                        </li>
                                        <li>上传表单
                                            <pre>
&lt;form action="testFileUpload" method="post" enctype="multipart/form-data">
    File : &lt;input type="file" name="file">
    Desc : &lt;input type="text" name="desc">
    &lt;input type="submit" value="submit">
&lt;/form>
                                            </pre>
                                        </li>
                                        <li>Handler处理
                                            <pre>
@RequestMapping(value="testFileUpload")
public String testFileUpload(@RequestParam("desc") String desc, 
        @RequestParam("file") MultipartFile file) throws IOException {
    System.out.println("desc : " + desc);
    System.out.println("OriginalFilename : " + file.getOriginalFilename());
    System.out.println("InputStream : " + file.getInputStream());
    return "success";
}</pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>自定义拦截器
                            <ul>
                                <li>SpringMVC可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定功能，自定义的拦截器必须实现HandlerInterceptor接口
                                    <ul>
                                        <li>preHandle() -
                                            在业务处理器处理请求之前被调用，在该方法中对用户请求request进行处理，如果拦截器对请求进行拦截处理后还需要调用其他的拦截器或业务处理器处理的话返回true，如果不需要再调用其他的组件去处理请求的返回false
                                            <ul>
                                                <li>在目标方法调用之前调用，返回true则放行，返回false则拦截</li>
                                                <li>可以用于权限，日志，事物等操作</li>
                                            </ul>
                                        </li>
                                        <li>postHandler() - 在业务处理器处理完请求后，DispatcherServlet向客户端返回响应前调用，在该方法中对用户请求request进行处理
                                            <ul>
                                                <li>在渲染视图前调用</li>
                                                <li>可以对请求域中的属性和视图进行修改</li>
                                            </ul>
                                        </li>
                                        <li>afterCompletion() - 在DispatcherServlet完全处理后调用，可以在该方法中进行一些资源的清理操作
                                            <ul>
                                                <li>渲染视图后调用</li>
                                                <li>用于释放资源</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>自定义拦截器实例
                                    <pre>
public class TestInterceptor implements HandlerInterceptor {
    @Override
    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)
    throws Exception {
        System.out.println("TestInterceptor : afterCompletion");
    }
    @Override
    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)
    throws Exception {
        System.out.println("TestInterceptor : postHandle");
    }
    @Override
    public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception {
        System.out.println("TestInterceptor : preHandle");
    return true;
    }
}
&lt;mvc:interceptors> 
    &lt;bean class="org.yang.demo.interceptors.TestInterceptor">&lt;/bean>
&lt;/mvc:interceptors></pre>
                                </li>
                                <li>配置文件
                                    <pre>
&lt;mvc:interceptors> 
    &lt;!-- 配置一个拦截器 -->
    &lt;mvc:interceptor>
        &lt;!-- 配置拦截器的拦截路径 -->
        &lt;mvc:mapping path="/testFileUpload"/>
        &lt;!-- 配置拦截器的不拦截的路径 -->
        &lt;mvc:exclude-mapping path="/admin"/>
        &lt;!-- 配置拦截器的bean-->
        &lt;bean class="org.yang.demo.interceptors.TestInterceptor"></bean>
    &lt;/mvc:interceptor>
&lt;/mvc:interceptors></pre>
                                </li>
                                <li>拦截器的执行顺序
                                    <br>FirstInterceptor#preHandle -> SecondInterceptor#preHandle(如果在此被拦截则直接跳转到FirstInterceptor#afterCompletion) -> HandlerAdapter#handler -> SecondInterceptor#postHandle -> FirstInterceptor#postHandle ->  DispatcherServlet#render -> SecondInterceptor#afterCompletion -> FirstInterceptor#afterCompletion
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <h3 id="page7">七. 异常处理与SpringMVC运行流程</h3>
                    <ol>
                        <li>异常处理
                            <ul>
                                <li>概述
                                    <ul>
                                        <li>SpringMVC通过HandlerExceptionResolver处理程序异常，包括Handler映射，数据绑定以及目标方法的执行</li>
                                        <li>SpringMVC提供的HandlerExceptionResolver实现类</li>
                                        <li>DispatcherServlet默认装配的HandlerExceptionResolver
                                            <ul>
                                                <li>没有使用&lt;mvc:annotation-driven/>
                                                    <ul>
                                                        <li>AnnotationMethodHandlerExceptionResolver</li>
                                                        <li>ResponseStatusExceptionResolver</li>
                                                        <li>DefaultHandlerExceptionResolver</li>
                                                    </ul>
                                                </li>
                                                <li>使用&lt;mvc:annotation-driven/>
                                                    <ul>
                                                        <li>ExceptionHandlerExceptionResolver</li>
                                                        <li>ResponseStatusExceptionResolver</li>
                                                        <li>DefaultHandlerExceptionResolver</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>@ExceptionHandler注解
                                    <ul>
                                        <li>使用@ExceptionHandler注解指明处理异常出现的方法，value参数传入需要处理的异常</li>
                                        <li>被@ExceptionHandler修饰的方法可以在入参中传入Exception对象获取异常信息</li>
                                        <li>若希望将异常信息输出到页面上，需要使用ModelAndView，不可以使用Map</li>
                                        <li>如果在handler类中没有找到处理异常的方法，则会寻找被@ControllerAdvice修饰的类中是否有对应得处理异常的方法</li>
                                        <li>e.g.
                                            <pre>
MainExceptionHandler.java
@ControllerAdvice
public class MainExceptionHandler {
@org.springframework.web.bind.annotation.ExceptionHandler(value={ArithmeticException.class})
public ModelAndView ExceptionHandler(Exception exception) {
    System.out.println("Exception! " + exception);
    ModelAndView modelAndView = new ModelAndView("error");
    modelAndView.addObject("exception", exception);
    return modelAndView;
}
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>@ResponseStatus注解
                                    <ul>
                                        <li>使用@ResponseStatus注解修饰自定义异常类可以定制状态码以及错误信息
                                            <br>value属性定制状态码，reason属性定制错误信息
                                        </li>
                                        <li>使用@ResponseStatus注解修饰Handler方法可以使正确执行的方法显示错误页面以及定制的错误信息，而程序会正常运行</li>
                                        <li>e.g.
                                            <pre>
@ResponseStatus(value=HttpStatus.NOT_FOUND, reason="Test")
public class LoginException extends RuntimeException {
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>DefaultHandlerExceptionHandler
                                    <br>对一些特殊的异常进行处理，例如:
                                    <ul>
                                        <li>NoSuchRequestHandlingMethodException</li>
                                        <li>HttpRequestMethodNotSupportedException</li>
                                        <li>HttpMediaTypeNotSupportedException</li>
                                        <li>HttpMediaTypeNotAcceptableException</li>
                                        <li>...</li>
                                    </ul>
                                </li>
                                <li>SimpleMappingExceptionResolver
                                    <ul>
                                        <li>
                                            如果希望对所有的异常进行统一的处理，可是使用SimpleMappingExceptionResolver，它将异常类映射为视图名，即发生异常后跳转的视图
                                        </li>
                                        <li>配置实例
                                            <pre>
&lt;bean id="simpleMappingExceptionResolver" 
  class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
&lt;property name="exceptionMappings">
    &lt;props>
        &lt;prop key="java.lang.ArithmeticException">error&lt;/prop>
    &lt;/props>
&lt;/property>
&lt;/bean></pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Spring MVC运行流程</li>
                        <img src="photo/springmvc/mvc9.png" class="am-img-responsive">
                    </ol>
                    <h3 id="page8">八. Spring整合Spring MVC</h3>
                    <ol>
                        <li>
                            通常情况下，数据源、事务、其它框架的整合以及DAO和Service的Bean都是在Spring的IOC容器中，而Handler以及与控制器相关的bean放在SpringMVC的IOC容器中
                        </li>
                        <li>SrpingMVC的IOC容器与Spring的IOC容器扫描的包存在重合则会创建两个对应的bean
                            <br>解决方案:
                            <ul>
                                <li>使SpingMVC与Spring的容器扫描的包不重合</li>
                                <li>使用过滤器对扫描的包进行过滤
                                    <ul>
                                        <li>SpringMVC的IOC容器仅包含Controller和ControllerAdvice</li>
                                        <li>Spring的IOC容器过滤掉所有的Controller和ControllerAdvice</li>
                                    </ul>
                                    <pre>
&lt;!-- SpringMVC配置自动扫描的包 -->
&lt;context:component-scan base-package="org.yang.demo" use-default-filters="false">
    &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/>
&lt;/context:component-scan>
&lt;!-- Spring配置自动扫描的包 -->
&lt;context:component-scan base-package="org.yang.demo">
    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/>
<&lt;context:component-scan></pre>
                                </li>
                            </ul>
                        </li>
                        <li>SpringMVC的IOC容器与Spring的IOC容器的关系
                            <br>SpringMVC容器中的bean可以引用Spring容器中的bean
                            <br>Spring容器中的bean不可以引用SpringMVC中的bean
                        </li>
                    </ol>
                    <h3 id="page9">九. Spring MVC与Struts区别</h3>
                    <ol>
                        <li>SpringMVC入口是Servlet，Struts入口是Filter</li>
                        <li>SpringMVC速度稍快与Struts，SpringMVC是基于方法设计的，而Struts是基于类设计的</li>
                        <li>SpringMVC更简洁，整体开发效率比Struts更高，支持JSR303，处理AJAX也更方便</li>
                        <li>SpringMVC没有OGNL与标签库，页面开发效率较低与Struts</li>
                    </ol>
                    <!--文章]]-->
                </div>
            </div>
        </div>
    </div>
    <div class="am-u-md-3 am-u-md-pull-9 my-sidebar" id="pageDesc">
        <div class="am-offcanvas" id="sidebar" data-am-sticky="{top:51}">
            <div class="am-offcanvas-bar">

                <ul class="am-nav">
                    <h1>Spring MVC</h1>
                    <!--导航[[-->
                    <li><a href="#!" id="btn1">概述与环境搭建</a></li>
                    <li><a href="#!" id="btn2">处理请求参数</a></li>
                    <li><a href="#!" id="btn3">视图与视图解析器</a></li>
                    <li><a href="#!" id="btn4">表单与静态资源</a></li>
                    <li><a href="#!" id="btn5">数据绑定/类型转换/格式化/校验</a></li>
                    <li><a href="#!" id="btn6">处理JSON/国际化/文件上传/自定义拦截器</a></li>
                    <li><a href="#!" id="btn7">异常处理与SpringMVC运行流程</a></li>
                    <li><a href="#!" id="btn8">Spring整合Spring MVC</a></li>
                    <li><a href="#!" id="btn9">Spring MVC与Struts区别</a></li>
                </ul>
                <!--导航]]-->
            </div>
        </div>
    </div>
    <!--<a href="#sidebar" class="am-btn am-btn-sm am-btn-success am-icon-bars am-show-sm-only my-button"
        data-am-offcanvas style="background-color: rgb(248,248,248); margin: 6px; border: 0; color: #666; font-size: 20px; z-index: 999;"><span class="am-sr-only">侧栏导航</span></a>-->
</div>

<!--页脚[[-->
<br><br><br>
<div class="am-g">
    <div class="am-u-lg-10 am-u-lg-offset-1" id="footer">
        <br>
        <span class="am-fl">Copyright © 2016-2017 yangyuhao</span>
        <span class="am-fr">联系我： QQ:1101632336 | Email:isyangyuhao@gmail.com | <a href="http://github.com/isyangyuhao">GitHub</a></span>
    </div>
</div>
<br><br><br>
<!--页脚]]-->

<!--[if lt IE 9]>
<script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
<script src="http://cdn.staticfile.org/modernizr/2.8.3/modernizr.js"></script>
<script src="assets/js/amazeui.ie8polyfill.min.js"></script>
<![endif]-->

<!--[if (gte IE 9)|!(IE)]><!-->
<script src="assets/js/jquery.min.js"></script>
<!--<![endif]-->
<script src="assets/js/amazeui.min.js"></script>
<script type="text/javascript">
    //加载进度条
    var progress = $.AMUI.progress;
    $(window).load(function() {
        progress.done();
    })
    $(document).ready(function() {
        progress.start();
    })
    //侧边栏平滑滚动
    $(window).smoothScroll();
    function navClick($btnObj, $pageObj) {
        $btnObj.on("click", function() {
            var $w = $(window);
            $w.smoothScroll({position: $pageObj.offset().top});
        })
    }
    navClick($("#btn1"), $("#page1"));
    navClick($("#btn2"), $("#page2"));
    navClick($("#btn3"), $("#page3"));
    navClick($("#btn4"), $("#page4"));
    navClick($("#btn5"), $("#page5"));
    navClick($("#btn6"), $("#page6"));
    navClick($("#btn7"), $("#page7"));
    navClick($("#btn8"), $("#page8"));
    navClick($("#btn9"), $("#page9"));

</script>
</body>
</html>
