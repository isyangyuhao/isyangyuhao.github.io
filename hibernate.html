<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>杨宇昊的学习笔记-Hibernate</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="format-detection" content="telephone=no">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <link rel="alternate icon" type="image/png" href="assets/i/favicon.png">
    <link rel="stylesheet" href="assets/css/amazeui.min.css"/>
    <!--Link Web Font-->
    <link href='//cdn.webfont.youziku.com/webfonts/nomal/21641/47115/58916519f629d80de474e740.css' rel='stylesheet' type='text/css' />
    <!--代码高亮highlight.js-->
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
    <script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>-->
    <!--Link Base Style-->
    <link rel="stylesheet" type="text/css" href="css/base.css">
    <link rel="stylesheet" type="text/css" href="css/page.css"/>
    <style type="text/css">
    </style>
</head>
<body>
<!--导航栏 [[-->
<header class="am-topbar" >
    <h1 class="am-topbar-brand css89d1c34bc5489">
        <a href="index.html" class="am-center" style="margin: 0 auto;">杨宇昊的学习笔记 <small>yangyuhao.org</small></a>
    </h1>
</header>
<!--导航栏 ]]-->
<div class="am-g am-g-fixed">
    <div class="am-u-md-9 am-u-md-push-3" id="pageContent">
        <div class="am-g">
            <div class="am-u-sm-11 am-u-sm-centered">
                <div class="am-cf am-article am-scrollable-horizontal">

                    <!--文章[[-->
                    <h2>第一部分 基础知识</h2>
                    <h3 id="page1">1.1 对象持久化与ORM</h3>
                    <ol>
                        <li>对象持久化
                            <ul>
                                <li>狭义的理解：持久化仅仅只把对象永久保存在数据库中</li>
                                <li>广义的理解：持久化包括和数据库相关的各种操作
                                    <ul>
                                        <li>保存 - 把对象永久保存到数据库中</li>
                                        <li>更新 - 更新数据库中对象(记录)的状态</li>
                                        <li>删除 - 从数据库中删除一个对象</li>
                                        <li>查询 - 根据特定的查询条件，把符合查询条件的一个或多个对象从数据库加载到内存中</li>
                                        <li>加载 - 根据特定的OID，把一个对象从数据库中加载到内存中
                                            <br>OID - 为了在系统中能够找到所需的对象，需要为每一个对象分配一个唯一的表示号，在关系数据库中称为主键，在对象术语中成为对象标示(Object identifier-OID)
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>ORM
                            <ul>
                                <li>ORM主要解决对象-关系映射
                                    <table class="am-table am-table-compact">
                                        <thead>
                                        <th>面向对象的概念</th>
                                        <th>面向关系的概念</th>
                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td>类</td>
                                            <td>表</td>
                                        </tr>
                                        <tr>
                                            <td>对象</td>
                                            <td>表的行</td>
                                        </tr>
                                        <tr>
                                            <td>属性</td>
                                            <td>表的列</td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>ORM思想：将关系数据库中表的记录映射为对象，以对象的形式展现，可以将数据库的操作转化为对对象的操作</li>
                                <li>ORM采用元数据来描述对象-关系映射细节，元数据通常采用XML格式，存放在专门的对象-关系映射文件中</li>
                                <li>关系图
                                    <img src="photo/hibernate/hibernate1.emf" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page2">1.2 Hibernate开发步骤</h3>
                    <ol>
                        <li>安装eclipse的hibernate插件
                            <br>安装方法说明:
                            <ul>
                                <li>Help --> Install New Software...</li>
                                <li>Click Add... </li>
                                <li>In dialog Add Site dialog, click Archive... </li>
                                <li>Navigate to hibernatetools-Update-4.1.1.Final_2013-12-08_01-06-33-B605.zip  and click  Open </li>
                                <li>Clicking OK in the Add Site dialog will bring you back to the dialog 'Install' </li>
                                <li>Select the Jboss Tools hibernatetools Nightly Build Update Site that has appeared</li>
                                <li>Click Next  and then Finish </li>
                                <li>Approve the license </li>
                                <li>Restart eclipse when that is asked</li>
                            </ul>
                        </li>
                        <li>准备Hibernate环境
                            <ul>
                                <li>导入Hibernate必须的jar包 - hibernate-release-4.2.4.Final\lib\required\*.jar</li>
                                <li>加入数据库驱动的jar包</li>
                            </ul>
                        </li>
                        <li>Hibernate开发步骤与实例
                            <ul>
                                <li>创建Hibernate配置文件 : src/hibernate.cfg.xml
                                    <pre>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">
&lt;hibernate-configuration>
    &lt;session-factory>
        &lt;!-- Hibernate 连接数据库基本信息 -->
        &lt;property name="connection.username">root&lt;/property>
        &lt;property name="connection.password">root&lt;/property>
        &lt;property name="connection.driver_class">com.mysql.jdbc.Driver&lt;/property>
        &lt;property name="connection.url">jdbc:mysql:///testh&lt;/property>
        &lt;!-- Hibernate 基本配置 -->
        &lt;property name="dialect">org.hibernate.dialect.MySQLDialect&lt;/property>
        &lt;property name="show_sql">true&lt;/property>
        &lt;property name="format_sql">true&lt;/property>
        &lt;property name="hbm2ddl.auto">update&lt;/property>
        &lt;!-- 设置Hibernate的事务隔离级别 -->
        &lt;property name="connection.isolation">2&lt;/property>
        &lt;!-- 删除对象后，使其OID置为null -->
        &lt;property name="use_identifier_rollback">true&lt;/property>
        &lt;!-- 配置C3P0数据源 -->
        &lt;!-- 数据库连接池的最大连接数 -->
        &lt;property name="hibernate.c3p0.max_size">10&lt;/property>
        &lt;!-- 数据库连接池的最小连接数 -->
        &lt;property name="hibernate.c3p0.min_size">5&lt;/property>
        &lt;!-- 连接池检测线程多长时间检测一次池内的所有链接对象是否超时 -->
        &lt;property name="hibernate.c3p0.idle_test_period">2000&lt;/property>
        &lt;!-- 数据库连接池中连接对象在多长时间没有使用过后，就应该被销毁 -->
        &lt;property name="hibernate.c3p0.timeout">2000&lt;/property>
        &lt;!-- 缓存Statement对象的数量 -->
        &lt;property name="hibernate.c3p0.max_statements">10&lt;/property>
        &lt;!-- 设定JDBC的Statement读取数据的时候每次从数据库中去除的记录条数 -->
        &lt;property name="hibernate.jdbc.fetch_size">100&lt;/property>
        &lt;!-- 设定对数据库进行批量删除，批量更新，批量插入时批次大小 -->
        &lt;property name="jdbc.batch_size">30&lt;/property>
        &lt;mapping resource="org/yang/demo/News.hbm.xml"/>
    &lt;/session-factory>
&lt;/hibernate-configuration></pre>
                                </li>
                                <li>创建持久化类 : src/org/yang/demo/News.java
                                    <pre>
package org.yang.demo;
import java.sql.Date;
public class News {
    private Integer id;
    private String title;
    private String author;
    private Date date;
    public News() {
    }
    public News(String title, String author, Date date) {
        this.author = author;
        this.title = title;
        this.date = date;
    }
    public String getAuthor() {
        return author;
    }
    public Date getDate() {
        return date;
    }
    public Integer getId() {
        return id;
    }
    public String getTitle() {
        return title;
    }
    public void setAuthor(String author) {
        this.author = author;
    }
    public void setDate(Date date) {
        this.date = date;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public void setTitle(String title) {
        this.title = title;
    }
    @Override
    public String toString() {
        return "News [id=" + id + ", title=" + title + ", author=" + author + ", date=" + date + "]";
    }
}</pre>
                                </li>
                                <li>创建对象-关系映射文件 : src/org/yang/demo/News.hbm.xml
                                    <pre>
&lt;?xml version="1.0"?>
&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
                                <!-- Generated 2016-8-18 0:00:54 by Hibernate Tools 3.4.0.CR1 -->
&lt;hibernate-mapping>
    &lt;class name="org.yang.demo.News" table="NEWS">
        &lt;id name="id" type="java.lang.Integer">
            &lt;column name="ID" />
            &lt;!-- 指定主键的生成方式，native:使用数据库本地的方式 -->
            &lt;generator class="native" />
        &lt;/id>
        &lt;property name="title" type="java.lang.String">
            &lt;column name="TITLE" />
        &lt;/property>
        &lt;property name="author" type="java.lang.String">
            &lt;column name="AUTHOR" />
        &lt;/property>
        &lt;property name="date" type="java.sql.Date">
            &lt;column name="DATE" />
        &lt;/property>
    &lt;/class>
&lt;/hibernate-mapping></pre>
                                </li>
                                <li>通过Hibernate API编写访问数据库代码
                                    <pre>
public class HibernateTest {
    @Test
    public void test() {
        //1. 创建SessionFactory对象
        SessionFactory sessionFactory = null;
        //1-1 创建Configuration对象，
                对应hibernate的基本配置信息和对象关系映射信息
        Configuration configuration = new Configuration().configure();
        //sessionFactory = configuration.buildSessionFactory();4.0前的方法已过期
        //1-2 创建ServiceRegistry对象,
                hibernate任何配置和服务都需要在该对象中注册才能有效
        ServiceRegistry serviceRegistry = new ServiceRegistryBuilder()
                .applySettings(configuration.getProperties())
                .buildServiceRegistry();
        sessionFactory = configuration.buildSessionFactory(serviceRegistry);
        //2. 创建一个Session对象
        Session session = sessionFactory.openSession();
        //3. 开启事务
        Transaction transaction = session.beginTransaction();
        //4. 执行保存操作
        News news = new News("test1", "yang",
                                new Date(new java.util.Date().getTime()));
        session.save(news);
        //5. 提交事务
        transaction.commit();
        //6. 关闭Session
        session.close();
        //7. 关闭SessionFactory
        sessionFactory.close();
    }
}</pre>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page3">1.3 基本配置</h3>
                    <ol>
                        <li>创建持久化java类要求
                            <ul>
                                <li>提供一个无参的构造器：使Hibernate可以使用Constructor.newInstance()来获取持久化类实例</li>
                                <li>提供一个标识属性：通常映射为数据库表的主键字段，如果没有该属性会使一些功能无法使用，例如Session.saveOrUpdate()</li>
                                <li>为类的持久化字段声明修改器和访问器：Hibernate对javaBean风格的属性实行持久化</li>
                                <li>使用非final类：运行时生成代理是Hibernate的重要功能，如果持久化类没有实现任何接口，Hibernate使用CGLIB生成代理，如果使用final类则无法生成CGLIB代理</li>
                                <li>重写equals和hashCode方法：如果需要将持久类的实例放到Set(当需要进行关联映射时)，重写这两个方法</li>
                                <li>Hibernate不要求持久化类继承任何父类和接口，以保证代码不被污染，因此称Hibernate为低侵入式设计</li>
                            </ul>
                        </li>
                        <li>Configuration
                            <ul>
                                <li>Configuration类负责管理Hibernate配置信息，包括
                                    <ul>
                                        <li>Hibernate运行的底层信息：数据库url，用户名，密码，JDBC驱动类，数据库Dialect，数据库连接池等(对应hibernate.cfg.xml)</li>
                                        <li>持久化类与数据表的映射关系(对应*.hbm.xml)</li>
                                    </ul>
                                </li>
                                <li>创建Configuration的方式
                                    <ul>
                                        <li>属性文件(hibernate.properties)
                                            <br><code>Configuration cfg = new Configuration();</code>
                                        </li>
                                        <li>xml文件(hibernate.cfg.xml)
                                            <br><code>Configuration cfg = new Configuration.configure();</code>
                                        </li>
                                        <li>指定xml配置文件
                                            <br><code>File file = new File("simpleit.xml");</code>
                                            <br><code>Configuration cfg = new Configuration.configure(file);</code>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>SessionFactory
                            <ul>
                                <li>针对单个数据库映射关系经过编译后的内存镜像，是线程安全的</li>
                                <li>SessionFactory对象一旦构建完毕，即被赋予特定的配置信息</li>
                                <li>SessionFactory是生成Session工厂</li>
                                <li>构造SessionFactory很消耗资源，一般情况下值初始化一个SessionFactory对象</li>
                                <li>Hibernate4新增了ServiceRegistry接口，所以基于Hibernate的配置或者服务都必须同一向ServiceRegistry注册后才生效</li>
                                <li>Hibernate4创建SessionFactory步骤：
                                    <ul>
                                        <li>创建Configuration对象
                                            <br><code>Configuration configuration = Configuration.configure();</code>
                                        </li>
                                        <li>创建ServiceRegistry对象
                                            <br><code>ServiceRegistryBuilder().applySettings(configuration.getProperties())<br>.buildServiceRegistry();</code>
                                        </li>
                                        <li>创建SessionFactory对象
                                            <br><code>SessionFactory sessionFactory = configuration<br>.buildSessionFactory(serviceRegistry);
                                            </code>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>事务Transaction
                            <ul>
                                <li>事务一次原子操作，它具有数据库事务的概念，所有持久层都应该在事务管理下进行，即使是读操作</li>
                                <li>开启事务：Transaction transaction = session.beginTransaction();</li>
                                <li>常用方法：
                                    <ul>
                                        <li>transaction.commit() - 提交相关联的实例</li>
                                        <li>transaction.rollback() - 撤销事务操作</li>
                                        <li>transaction.wasCommitted() - 检查事务是否提交</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>hbm2ddl.auto配置项
                            <ul>
                                <li>该属性可以实现正向工程，即由java生成数据库脚本，进而生成具体的表结构</li>
                                <li>属性取值
                                    <ul>
                                        <li>create：会根据.hbm.xml文件来生成数据表，但每次运行都会删除上一次的表重新生成，哪怕第二次没有改变</li>
                                        <li>create-drop：会根据.hbm.xml文件来生成表，但是SessionFactory一旦关闭就自动删除</li>
                                        <li>update：常用属性值，根据.hbm.xml文件生成表，若.hbm.xml和数据库中对应数据表结构不同，Hibernate将更新表结构，不会删除已有项</li>
                                        <li>validate：和数据库中的表进行比较，若.hbm.xml文件中列在数据表中不存在，则抛出异常</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Hibernate配置C3P0数据源
                            <ul>
                                <li>导入jar包 ： hibernate-release.Final\lib\optional\c3p0\*.jar</li>
                                <li>加入配置文件
                                    <pre>
&lt;!-- 数据库连接池的最大连接数 -->
&lt;property name="hibernate.c3p0.max_size">10&lt;/property>
&lt;!-- 数据库连接池的最小连接数 -->
&lt;property name="hibernate.c3p0.min_size">5&lt;/property>
&lt;!-- 连接池检测线程多长时间检测一次池内的所有链接对象是否超时 -->
&lt;property name="hibernate.c3p0.idle_test_period">2000&lt;/property>
&lt;!-- 数据库连接池中连接对象在多长时间没有使用过后，就应该被销毁 -->
&lt;property name="hibernate.c3p0.timeout">2000&lt;/property>
&lt;!-- 缓存Statement对象的数量 -->
&lt;property name="hibernate.c3p0.max_statements">10&lt;/property></pre>
                                </li>
                            </ul>
                        </li>
                        <li>配置项jdbc.fetch_size和jdbc.batch_size属性
                            <ul>
                                <li>hibernate.jdbc.fetch_size：
                                    <br>设定JDBC的Statement读取数据时每次从数据库中读取的记录条数，常设置fetchSize=100；mySql不支持该特性
                                </li>
                                <li>hibernate.jdbc.batch_size：
                                    <br>设定对数据库进行批量删除，批量更新，批量插入时候的批次大小，常设置batchSize=30
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page4">1.4 Session & CRUD</h3>
                    <ol>
                        <li>概述
                            <ul>
                                <li>Session接口是Hibernate向应用程序提供操纵数据库的最主要接口，提供基本的保存，更新，删除，加载java对象的方法</li>
                                <li>Session具有一个缓存，位于缓存中的对象成为持久化对象，它和数据库中的相关记录对应，Session能够在某些时间点按照缓存中对象的变化来执行相关sql语句同步更新数据库，这一过程成为刷新缓存</li>
                                <li>在持久化角度，Hibernate将对象分为4种状态：持久化状态，临时状态，游离状态，删除状态；Sessionde的特定方法能使对象从一个转换转换到另一状态</li>
                            </ul>
                        </li>
                        <li>Session类的方法
                            <ul>
                                <li>取得持久化对象的方法：get()，load()</li>
                                <li>持久化对象保存，更新，删除：save()，update()，saveOrUpdate()，delete()</li>
                                <li>开启事务：beginTransaction()</li>
                                <li>管理Session方法：isOpen()，flush()，clear()，evict()，close()，refresh()</li>
                            </ul>
                        </li>
                        <li>Session缓存(一级缓存)
                            <ul>
                                <li>
                                    在Session接口实现的中包含一系列java集合，这些java集合构成了Session缓存，
                                    只要Session实例没有结束生命周期，且没有清理缓存，则存放在缓存中的对象也不会结束生命周期
                                </li>
                                <li>Session缓存可以减少Hibernate应用程序访问数据库的频率</li>
                                <li>flush：为了使数据表中的记录和Session缓存中的对象保持一致，则可能会发送对应的sql语句
                                    <ul>
                                        <li>在Transaction的commit()方法中，先自动调用session的flush方法，再提交事务</li>
                                        <li>flush()方法可能会发送sql语句，但不会提交事务</li>
                                        <li>再未执行session.flush()方法之前，也有可能进行flush操作
                                            <br>执行HQL或QBC查询，会先进行flush操作，以得到数据表的最新记录
                                        </li>
                                        <li>例外情况：若记录的ID是由底层的数据库自增的方式生成的，则在调用save()方法之后，会立即发送INSERT语句，因为save方法后必须保证对象的ID是存在的</li>
                                    </ul>
                                </li>
                                <li>refresh：会强制发送SELECT语句，以使Session缓存中对象的状态和数据表中的内容一致
                                    <br>mysql默认的隔离级别为"可重复读"，需要修改为"读已提交"，修改方法：在hibernate.cfg.xml中添加
                                    <pre>
&lt;!-- 设置Hibernate的事务隔离级别 -->
&lt;property name="connection.isolation">2&lt;/property></pre>
                                </li>
                                <li>clear：清理缓存</li>
                                <li>Session缓存与数据库的关系
                                    <img src="photo/hibernate/hibernate2.emf" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>持久化对象的状态
                            <ul>
                                <li>临时对象
                                    <ul>
                                        <li>在使用代理主键的情况下，OID通常为null</li>
                                        <li>不出在Session缓存中</li>
                                        <li>在数据库中没有对应的记录</li>
                                    </ul>
                                </li>
                                <li>持久化对象
                                    <ul>
                                        <li>OID不为null</li>
                                        <li>位于Session缓存中</li>
                                        <li>若在数据库中已有和其对应的记录，持久化对象和数据库中的相关记录对应</li>
                                        <li>Session在flush缓存时，会根据持久化对象的属性变化来同步更新数据库</li>
                                        <li>在同一个Session缓存实例中，数据表表中的每条记录只对应唯一的持久化对象</li>
                                    </ul>
                                </li>
                                <li>删除对象
                                    <ul>
                                        <li>在数据库中没有和其OID对应的记录</li>
                                        <li>不在处于Session缓存中</li>
                                        <li>一般情况下，应用程序不该再使用被删除的对象</li>
                                    </ul>
                                </li>
                                <li>游离对象(托管对象)
                                    <ul>
                                        <li>OID不为null</li>
                                        <li>不再处于Session缓存中</li>
                                        <li>一般情况下，游离对象是有持久化对象转变过来的，因此在数据库中可能还存在与其对应的记录</li>
                                    </ul>
                                </li>
                                <li>对象状态转换图
                                    <img src="photo/hibernate/hibernate3.emf" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>Session API
                            <ul>
                                <li>save(Object obj);  //将临时对象转变为持久化对象
                                    <ul>
                                        <li>为对象分配OID</li>
                                        <li>在flush缓存时会发送INSERT语句</li>
                                        <li>持久化对象的id不能随意修改</li>
                                        <li>在执行save()前设置ID值无效</li>
                                    </ul>
                                </li>
                                <li>persist(Object obj);  //将临时对象转变为持久化对象
                                    <ul>
                                        <li>功能同save()</li>
                                        <li>save&persist区别：在执行persist()方法前设置ID值不会执行INSERT并且会抛出异常，save则当作ID不存在继续执行</li>
                                    </ul>
                                </li>
                                <li>get(Class clazz, int index);  //根据OID从数据库中加载一个持久化对象</li>
                                <li>load(Class clazz, int index);  //根据OID从数据库中加载一个持久化对象
                                    <br>get&load区别
                                    <ul>
                                        <li>执行get方法会立即加载对象(立即检索)，执行load方法如果不使用该对象则不会立即执行查询操作，而是返回代理一个对象(延迟检索)</li>
                                        <li>若数据表中没有记录，get方法会返回null，load则会抛出异常</li>
                                        <li>load方法可能会抛出LazyInitializationException异常：在需要初始化代理对象之前关闭了session，若不使用该对象的任何属性则不会有问题</li>
                                    </ul>
                                </li>
                                <li>upload(Object obj);  //使一个游离对象转变为持久化对象，并计划执行一条UPDATE语句
                                    <br>若更新一个持久化对象，不需要显式的调用update方法
                                    <ul>
                                        <li>在调用Transaction的commit()方法时，先会执行session的flush方法</li>
                                        <li>更新一个游离状态，需要显示的调用session的update方法，可以将游离对象变为持久化对象</li>
                                        <li>无论更新的游离对象和数据表是否一致，都会发送update语句，在.hbm.xml文件的class结点设置 select-before-update="true"可以避免，通常情况下不设置，除非使用触发器</li>
                                        <li>若数据表中没有对应的记录，但还调用的update方法，则会抛出异常</li>
                                        <li>当update()方法关联一个游离对象时，如果Session的缓存中已经存在相同的OID的持久化对象，会抛出异常，Session缓存中不能有两个相同OID对象</li>
                                    </ul>
                                </li>
                                <li>saveOrUpdate(Object obj);  //包含了Session的save和update方法
                                    <ul>
                                        <li>若执行的对象是游离对象则执行update，是临时对象的话则执行save</li>
                                        <li>判断对象是游离还是临时的标准为OID，OID为null是临时对象，OID不为null则是游离对象</li>
                                        <li>OID值等于id的unsaved-value属性值的对象也被认为是一个游离对象</li>
                                        <li>若OID不为空，但数据表中还没有和其对应的记录，则会抛出异常</li>
                                    </ul>
                                </li>
                                <li>delete(Object obj);  //删除游离对象或持久化对象
                                    <ul>
                                        <li>只要OID和数据表中有一条记录对应，就会准备执行delete操作</li>
                                        <li>若OID在数据表中没有对应的记录，则抛出异常</li>
                                        <li>Hibernate的cfg.xml配置文件中如果将hibernate.use_identifier_rollback属性设置为true，则delete方法会将持久化对象或游离对象的OID设置为null，使他们变成临时对象</li>
                                    </ul>
                                </li>
                                <li>evict(Object obj);  //从session缓存中把指定的对象移出</li>
                            </ul>
                        </li>
                        <li>通过Hibernate调用存储过程
                            <ul>
                                <li>Work接口：直接通过JDBC API访问数据库的操作</li>
                                <li>Session的doWork(Work)方法用于执行Work对象指定的操作，即调用Work对象的execute()方法，Session会把当前使用的数据库连接传递给execute()方法</li>
                                <li>Hibernate没有提供存储过程的接口，需要使用原生JDBC调用存储过程
                                    <pre>
@Test
public void testDoWork() {
    session.doWork(new Work() {
        @Override
        public void execute(Connection arg0) throws SQLException {
            //调用存储过程
        }
    });
}</pre>
                                </li>
                            </ul>
                        </li>
                        <li>Hibernate与触发器协同工作
                            <ul>
                                <li>Hibernate与数据库中的触发器协同工作时会出现的问题
                                    <ul>
                                        <li>触发器使Session的缓存中的持久化对象与数据库中对应的数据不一致:触发器运行在数据库中, 它执行的操作对Session是透明的</li>
                                        <li>Session的update()方法盲目地激发触发器:无论游离对象的属性是否发生变化, 都会执行update语句, 而update语句会激发数据库中相应的触发器</li>
                                    </ul>
                                </li>
                                <li>解决方案
                                    <ul>
                                        <li>在执行完Session的相关操作后,立即调用Session的flush()和refresh()方法,迫使Session的缓存与数据库同步(refresh()方法重新从数据库中加载对象)</li>
                                        <li>在映射文件的的<class>元素中设置select-before-update属性:当 Session的update或saveOrUpdate()方法更新一个游离对象时, 会先执行 Select 语句, 获得当前游离对象在数据库中的最新数据, 只有在不一致的情况下才会执行update 语句</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h2>第二部分 映射</h2>
                    <h3 id="page5">2.1 类与表的映射</h3>
                    <ol>
                        <li>类与表的映射
                            <table class="am-table am-table-compact">
                                <tbody>
                                <tr>
                                    <td>name</td>
                                    <td>指定该持久化类映射的持久化类的类名</td>
                                </tr>
                                <tr>
                                    <td>table</td>
                                    <td>指定该持久化类映射的表名，Hibernate默认支持持久化类名作为表名
                                    </td>
                                </tr>
                                <tr>
                                    <td>dynamic-insert</td>
                                    <td>若设置为true，表示当保存一个对象时，会动态生成一个insert语句，insert语句中仅包含所有取值不为null的字段，默认值为false</td>
                                </tr>
                                <tr>
                                    <td>dynamic-update</td>
                                    <td>若设置为true，表示当更新一个对象时，会动态生成update语句，update语句中仅包含所有取值需要更新的字段，默认false</td>
                                </tr>
                                <tr>
                                    <td>select-before-update</td>
                                    <td>设置Hibernate在更新某个持久化对象之前是否需要先执行一次查询，默认值为false</td>
                                </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>映射对象标识符
                            <ul>
                                <li>
                                    Hibernate使用对象标识符(OID)来建立内存中的对象和数据库表中记录的对应关系，对象的OID和数据表的主键对应，Hibernate通过标识符生成器来为主键赋值
                                </li>
                                <li>Hibernate推荐在数据表中使用代理主键，即不具备业务逻辑含义的字段，代理逐渐通常为整数类型，因为整数类型比字符串类型要节省更多的数据库空间</li>
                                <li>在对象-关系映射文件中，&lt;id>元素用来设置对象标识符，&lt;generator>子元素用来设定标识符生成器</li>
                                <li>Hibernate提供了标识符生成器接口：IdentifierGenerator，并提供了各种实现</li>
                                <li>hbm.xml中的id元素：设定持久化类的OID和表的主键映射
                                    <br>属性
                                    <table class="am-table am-table-compact">
                                        <tbody>
                                        <tr>
                                            <td>name</td>
                                            <td>标识持久化类OID的属性名</td>
                                        </tr>
                                        <tr>
                                            <td>column</td>
                                            <td>设置标识属性所映射的数据表的列明(主键字段名)</td>
                                        </tr>
                                        <tr>
                                            <td>unsaved-value</td>
                                            <td>若设定该属性，Hibernate会通过比较持久化类的OID之和该属性值来区分当前持久化类的对象是否为临时对象</td>
                                        </tr>
                                        <tr>
                                            <td>type</td>
                                            <td>指定Hibernage映射类型，Hibernate映射类型是Java类型与sql类型的桥梁</td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>hbm.xml中的generator元素：设定持久化类标识符生成器
                                    <br>class属性: 指定使用标识符生成器全限定类名或其缩写
                                    <br>主键生成策略:
                                    <ul>
                                        <li>increment标识符生成器
                                            <ul>
                                                <li>increment标识符生成器有Hibernate以递增的方式为代理主键赋值</li>
                                                <li>Hibernate会先读取表中逐渐的最大值，然后再向表中插入记录时就在max(id)的基础上递增，增量为1</li>
                                                <li>适用范围
                                                    <ul>
                                                        <li>由于increment生成标识符机制不依赖与底层数据库，因此适用于所有数据库系统</li>
                                                        <li>适用于只有单个Hibernate应用进程访问同一个数据库的场合，在集群环境下不推荐使用</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                        <li>identity标识符生成器
                                            <ul>
                                                <li>identity标识符生成器由底层数据库来负责生成标识符，它要求底层数据库把主键定义为自动增长字段类型</li>
                                                <li>适用范围: 由于identity生成标识符的机制依赖于底层数据库，因此要求底层数据库支持自动增长字段类型，支持自动增长类型的数据库包括：DB2,Mysql,MSSQLSever,Sybase等，Oracle数据库不支持</li>
                                            </ul>
                                        </li>
                                        <li>sequence标识符生成器
                                            <ul>
                                                <li>sequence标识符生成器利用底层数据库提供的序列来生成标识符
                                                    <pre>
&lt;id name="id" type="java.lang.Integer">
    &lt;column name="ID">&lt;/column>
    &lt;generator class="sequence">
        &lt;param name="sequence">tbname_sql&lt;/param>
    &lt;/generator>
&lt;/id></pre>
                                                </li>
                                                <li>Hibernate在持久化一个对象时，先从底层数据库的序列中获得唯一标识号，再将其作为主键值</li>
                                                <li>适用范围: 由于sequence生成标识符的机制依赖于底层数据库的序列，因此要求底层数据库必须支持序列，支持的数据库包括：DB2,Oracle等</li>
                                            </ul>
                                        </li>
                                        <li>hilo标识符生成器
                                            <ul>
                                                <li>hild标识符生成器有Hibernate按照一种high/low算法生成标识符，它从数据库的特定表的字段中获取high值</li>
                                                <li>
                                                    Hibernate在持久化一个对象时，由Hibernate负责生成主键值，hilo标识符生成器在生成标识符时需要读取并修改HI_TABLE表中的NEXT_VALUE值
                                                </li>
                                                <li>适用范围: 由于hili标识符机制不依赖底层数据库，因此适用于所有数据库系统</li>
                                            </ul>
                                        </li>
                                        <li>native标识符生成器
                                            <ul>
                                                <li>native标识符生成器依据底层数据库对自动生成标识符的支持能力来选择使用identity/sequence/hili标识符生成器</li>
                                                <li>适用范围: 由于native能根据底层数据库系统的类型自动选择合适的标识符生成器，因此很适合于跨数据库平台开发</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>hbm.xml中的property元素：用于指定类的属性和表的字段的映射
                                    <br>属性
                                    <table class="am-table am-table-compact">
                                        <tbody>
                                        <tr>
                                            <td>name</td>
                                            <td>指定该持久化类的属性的名称</td>
                                        </tr>
                                        <tr>
                                            <td>column</td>
                                            <td>指定与类属性想映射的表的字段名，如果没有该值，Hibernate将直接使用类的属性名作为字段名</td>
                                        </tr>
                                        <tr>
                                            <td>type</td>
                                            <td>指定Hibernate映射类型</td>
                                        </tr>
                                        <tr>
                                            <td>not-null</td>
                                            <td>若该属性值为true，则表明不允许为null，默认为false</td>
                                        </tr>
                                        <tr>
                                            <td>access</td>
                                            <td>
                                                指定Hibernate默认的属性访问策略，默认值为porperty，即使用getter,setter方法来访问属性，若指定field，则Hibernate会忽略getter/setter方法，通过反射访问成员变量
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>unique</td>
                                            <td>设置是否为该属性所映射的数据列添加唯一约束</td>
                                        </tr>
                                        <tr>
                                            <td>index</td>
                                            <td>指定一个字符的索引名称，当系统需要Hibernate自动建表时，用于为该属性所映射的数据列创建索引，从而加快该数据列的查询</td>
                                        </tr>
                                        <tr>
                                            <td>length</td>
                                            <td>指定该属性所映射数据列的小数位数，对double, float, decimal等类型数据列有效</td>
                                        </tr>
                                        <tr>
                                            <td>formula</td>
                                            <td>设置sql表达式，Hibernate将根据它的计算来派生属性的值</td>
                                        </tr>
                                        <tr>
                                            <td>update</td>
                                            <td>如果设置为true，则当前字段不可以修改</td>
                                        </tr>
                                        </tbody>
                                    </table>
                                    使用formula属性:
                                    <ul>
                                        <li>formula = "(sql)"的英文括号不可以省略</li>
                                        <li>sql表达式中的列名和表名都应该和数据库对应，而不是和持久化对象的属性对应</li>
                                        <li>如果需要在formula属性中使用参数，直接使用"where cur.id=id"形式即可</li>
                                        <li>e.g.
                                            <pre>
&lt;property name="descpt" formula="(SELECT concat(author,':',title) FROM NEWS n WHERE n.id = id)">
&lt;/property>
					News news = (News) session.get(News.class, 1);
System.out.println(news.getDescpt());</pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>java类型， Hibernate映射类型，SQL类型对应关系表
                            <img src="photo/hibernate/hibernate4.emf" class="am-img-responsive">
                            <img src="photo/hibernate/hibernate5.emf" class="am-img-responsive">
                        </li>
                        <li>时间和日期类型映射
                            <ul>
                                <li>在java中，代表时间和日期类型包括：java.util.Date, java.util.Calendar，在JDBC
                                    API中提供了三个扩展java.util.Date的子类：java.sql.Date, java.sql.Time,
                                    java.sql,Timestamp，这三个类分别与sql类型中的DATE, TIME, TIMESTAMP类型相对应
                                </li>
                                <li>在标准sql中，DATE类型代表日期，TIME类型代表时间，TIMESTAMP类型表示时间戳
                                    <img src="photo/hibernate/hibernate6.png" class="am-img-responsive">
                                </li>
                                <li>在开发中，根据持久化属性，使用Hibernate映射类型相与之对应</li>
                            </ul>
                        </li>
                        <li>大对象类型映射
                            <ul>
                                <li>在java中，java.lang.String可用于表示长字符串(len>255)，字节数组byte[]可用于存放图片或文件的二进制数据，在JDBC
                                    API中提供了java.sql.Clob,
                                    java.sql.Blob类型，分别和标准sql中的CLOB,BLOB类型对应，CLOB表示字符串大对象，BLOB表示二进制大对象
                                    <img src="photo/hibernate/hibernate7.png" class="am-img-responsive">
                                </li>
                                <li>mysql不支持标准sql的CLOB类型，在mysql中用TEXT, MEDIUMTEXT, LONGTEXT类型表示长度大于255的长文本数据</li>
                                <li>在持久化类中，二进制大对象可以生命为byte[]或java.sql.Blob类型，字符串可以生命为java.lang.String或java.sql.Clob</li>
                                <li>在开发中处理长度超过255的字符串使用java.lang.String比java.sql.Clob更方便</li>
                                <li>e.g. 存放大对象数据
                                    <pre>
*.hbm.xml
<!-- 映射大对象 -->
<!-- 若想要精确映射sql类型，可以使用sql-type类型 -->
&lt;property name="content" type="clob">
    &lt;column name="CONTENT" sql-type="mediumtext">&lt;/column>
&lt;/property>
&lt;property name="image" type="blob">
    &lt;column name="IMAGE" sql-type="mediumblob">&lt;/column>
&lt;/property>
javaBean.java
//大文本
private String content;
//二进制文件
private Blob image;
//getter() & setter() …
Test.java
News news = new News("test", "yang", new Date());
InputStream inputStream = new FileInputStream("photo.jpg");
Blob image = Hibernate.getLobCreator(session).createBlob(inputStream, inputStream.available());
news.setImage(image);
session.save(news);</pre>
                                </li>
                                <li>e.g. 读取大对象数据
                                    <pre>
@Test
public void testBlob() throws IOException, SQLException {
    News news = (News) session.get(News.class, 1);
    Blob image = news.getImage();
    InputStream inputStream = image.getBinaryStream();
}</pre>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page6">2.2 映射关联关系</h3>
                    <ol>
                        <li>映射组合关联关系
                            <ul>
                                <li>域模型：由程序代码组成，通过细化持久化类的粒度提高代码的可重用性；
                                    在没有数据冗余的情况下尽可能的减少表的数目与参照关系
                                    <img src="photo/hibernate/hibernate8.png" class="am-img-responsive"></li>
                                <li>持久化类的属性分类
                                    <ul>
                                        <li>值(value)类型：没有OID，不能被单独持久化，生命周期依赖于所属的持久化类的对象的生命周期</li>
                                        <li>实体(entity)类型：有OID，可以被单独持久化，有独立的生命周期</li>
                                    </ul>
                                </li>
                                <li>组件：类的属性是另一个持久化类的组成部分称为组件，在Hibernate中使用component元素来映射组成关系</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate9.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate10.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>映射单向多对一关联关系
                            <ul>
                                <li>双向1-n与双向n-1是完全相同的两种情形，双向1-n可以在一端访问另一端</li>
                                <li>域模型：从n端到1端的多对一双向关联需要在n端存放一个1端的对象作为属性，在1端存放n端类型的集合属性
                                    <img src="photo/hibernate/hibernate11.png" class="am-img-responsive">
                                </li>
                                <li>关系数据模型：n端的外键参照1端的主键</li>
                                <li>当Session从数据库中加载java集合时，创建的是Hibernate内置集合类的实例，因此在持久化类中定义集合属性时必须把属性声明为java接口类型
                                    <ul>
                                        <li>Hibernate的内置集合类具有集合代理功能，支持延迟检索策略</li>
                                        <li>事实上，Hibernate的内置集合类封装了JDK集合类，使Hibernate能够对缓存中的集合对象进行脏检查，按照集合对象的状态同步更新数据库</li>
                                    </ul>
                                </li>
                                <li>定义集合属性时，通常把初始化为集合实现类的一个实例，提供程序的健壮性，避免应用程序访问取值为null的集合的方法抛出空指针异常</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate12.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate13.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>映射双向一对多关联关系
                            <ul>
                                <li>双向1-n与双向n-1是完全相同的两种情形，双向1-n可以在一端访问另一端</li>
                                <li>域模型：从n端到1端的多对一双向关联需要在n端存放一个1端的对象作为属性，在1端存放n端类型的集合属性
                                    <img src="photo/hibernate/hibernate14.png" class="am-img-responsive">
                                </li>
                                <li>关系数据模型：n端的外键参照1端的主键</li>
                                <li>当Session从数据库中加载java集合时，创建的是Hibernate内置集合类的实例，因此在持久化类中定义集合属性时必须把属性声明为java接口类型
                                    <ul>
                                        <li>Hibernate的内置集合类具有集合代理功能，支持延迟检索策略</li>
                                        <li>事实上，Hibernate的内置集合类封装了JDK集合类，使Hibernate能够对缓存中的集合对象进行脏检查，按照集合对象的状态同步更新数据库</li>
                                    </ul>
                                </li>
                                <li>定义集合属性时，通常把初始化为集合实现类的一个实例，提供程序的健壮性，避免应用程序访问取值为null的集合的方法抛出空指针异常</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate15.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate16.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate17.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>set元素
                            <ul>
                                <li>用来映射持久化了类中set类型的属性</li>
                                <li>set元素的inverse属性
                                    <ul>
                                        <li>
                                            在hibernate中通过对inverse属性来决定是有双向关联的哪一方来维护表和表之间的关系，inverse=false为主动方/inverse=true为被动方，由主动方负责维护关联关系
                                        </li>
                                        <li>在没有设置inverse属性的情况下，父子双方都维护父子关系</li>
                                        <li>在1-n关系中，将n端设置为主动方有助于性能改善，如果将1端设置为主动方，则会发生多余update语句和插入数据时无法同时插入外键列，无法添加非空约束等问题</li>
                                    </ul>
                                </li>
                                <li>cascade属性
                                    <ul>
                                        <li>
                                            在对象-关系映射文件中，用于映射持久化类之间关联的元素set,many-to-one,one-to-one都有cascade属性，用于指定如何操作与当前对象的其他对象
                                        </li>
                                        <li>属性
                                            <img src="photo/hibernate/hibernate18.png" class="am-img-responsive">
                                        </li>
                                    </ul>
                                </li>
                                <li>在数据库中队集合排序
                                    <ul>
                                        <li>在set元素中使用order-by属性，使Hibernate通过select语句到数据库检索集合对象时，利用order by语句进行排序</li>
                                        <li>order-by属性允许使用sql函数 </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>基于外键映射双向一对一关联关系
                            <ul>
                                <li>域模型:
                                    <img src="photo/hibernate/hibernate19.png" class="am-img-responsive">
                                </li>
                                <li>关系数据模型：选择其中一个1端设置外键指向另一个1端的主键</li>
                                <li>对于基于外键的双向一对一关联，其外键可以存放任意一遍，在需要存放外键的一段增加many-to-one元素，并为元素增加unique=true的属性</li>
                                <li>没有使用外键的一端需要使用one-to-one元素，并为元素增加property-ref属性指定使用被关联实体主键以外的字段作为关联字段</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate20.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate21.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate22.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>基于主键映射双向一对一关联关系
                            <ul>
                                <li>一端的主键生成器使用foreign策略，表名根据对方的主键生成自己的主键，自己不能独立生成主键，param子元素指定当前property使用当前持久化类的哪一个属性作为对方</li>
                                <li>采用foreign主键生成策略的一段增加one-to-one元素映射关联属性，其one-to-one属性还应增加constrained=true属性，另一端zengjiaone-to-one元素映射关联属性</li>
                                <li>constrained：指定当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象所对应的数据库主键</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate23.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate24.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>映射单向多对多关联关系
                            <ul>
                                <li>域模型
                                    <img src="photo/hibernate/hibernate25.png" class="am-img-responsive">
                                </li>
                                <li>关系数据模型：使用连接表，分别存放两个实体对应主键作为外键</li>
                                <li>与1-n映射类似，必须为set集合元素添加key子元素，指定参照表的外键名，set中使用many-to-many子元素，class属性制定items集合中存放的Item对象，column属性指定其参照的外键名</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate26.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate27.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>映射双向多对多关联关系
                            <ul>
                                <li>域模型
                                    <img src="photo/hibernate/hibernate28.png" class="am-img-responsive">
                                </li>
                                <li>关系数据模型：使用连接表，分别存放两个实体对应主键作为外键</li>
                                <li>在双向n-n关联的两边都需要指定连接表的表名及外键列的列明，连个集合set元素的taable属性必须指定相同的连接表，两边的key与many-to-many的column属性交叉相同</li>
                                <li>双向n-n关联，需要在一段将set的inverse属性设置为true，否则两段都维护关系会导致主键冲突</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate29.png" class="am-img-responsive">
                                    <img src="photo/hibernate/hibernate30.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page7">2.3 继承映射</h3>
                    <ol>
                        <li>继承映射：对于面向对象的程序设计语言而言，继承和多态是两个最基本的概念。Hibernate的继承映射可以理解为持久化类之间的继承关系</li>
                        <li>继承映射策略
                            <ul>
                                <li>subclass - 将域模型中的每一个实体对象映射到一个独立的表中，也就是说不用在关系数据模型中考虑域模型中的继承关系和多态</li>
                                <li>joined-subclass - 对于继承关系中的子类使用同一个表，这就需要在数据库表中增加额外的区分子类类型的字段</li>
                                <li>union-subclass - 域模型中的每个类映射到一个表，通过关系数据模型中的外键来描述表之间的继承关系。这也就相当于按照域模型的结构来建立数据库中的表，并通过外键来建立表之间的继承关系</li>
                            </ul>
                        </li>
                        <li>持久化类示例
                            <img src="photo/hibernate/hibernate31.png" class="am-img-responsive">
                        </li>
                        <li>subclass继承映射
                            <ul>
                                <li>采用subclass继承映射可以实现对继承关系中父类和子类使用同一张表</li>
                                <li>辨别者列：因为父类和子类需要保存在同一张表，因此需要在该表内增加一列，使用该列来区分每行记录到底是哪一个类的实例</li>
                                <li>在这种策略映射下，使用subclass元素来映射子类，使用class和subclass的discriminator-value属性指定辨别者列的值</li>
                                <li>所有子类定义的字段不能有非空约束</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate32.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>joined-subclass继承映射
                            <ul>
                                <li>采用joined-subclass元素的继承映射可以实现每一个子类一张表</li>
                                <li>采用这种映射策略，父类实例保存在父类表中，子类实例由父类表和子类表共同存储，子类表新增的属性保存在子类表中</li>
                                <li>这种映射策略不需要辨别者列，但需要每个子类使用key元素映射共有主键</li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate33.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>union-subclass继承映射
                            <ul>
                                <li>采用union-sublcass元素可以实现每一个实体对象映射到一个独立的表中</li>
                                <li>子类增加的属性可以有非空约束，子类的数据保存在子表中，父类的数据保存在父表中</li>
                                <li>子类实例的数据仅保存在子类表中，在父类表中没有任何记录</li>
                                <li>该映射策略既不需要鉴别这列也不需要key元素映射主键</li>
                                <li>
                                    在union-subclass映射策略不可以使用identity的主键生成策略，因为同一类继承层次中所有实体类都需要同一个主键种子，也不能使用native生成策略，应该使用hilo
                                </li>
                                <li>e.g.
                                    <img src="photo/hibernate/hibernate34.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>三种继承映射方式比较
                            <img src="photo/hibernate/hibernate35.emf" class="am-img-responsive">
                        </li>
                    </ol>
                    <h2>第三部分 更多操作</h2>
                    <h3 id="page8">3.1 检索</h3>
                    <ol>
                        <li>检索策略
                            <ul>
                                <li>类级别和关联级别可选的检索策略
                                    <img src="photo/hibernate/hibernate36.png" class="am-img-responsive">
                                </li>
                                <li>检索策略的运行机制
                                    <img src="photo/hibernate/hibernate37.png" class="am-img-responsive">
                                </li>
                                <li>映射文件中用于设定检索策略的属性
                                    <img src="photo/hibernate/hibernate38.png" class="am-img-responsive">
                                </li>
                                <li>检索策略特点
                                    <img src="photo/hibernate/hibernate39.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>检索方式
                            <ul>
                                <li>导航对象图检索方式：根据已经加载的对象导航到其他对象</li>
                                <li>OID检索方式：按照对象的OID来检索对象</li>
                                <li>HQL检索方式：使用面向对象的OID来检索对对象</li>
                                <li>QBC检索方式：使用QBC(Query By Criteria)API来检索对象，这种API封装了就字符串形式的查询语句，提供了更加面向对象的查询接口</li>
                                <li>本地SQL检索方式：使用本地数据库的SQL查询语句</li>
                            </ul>
                        </li>
                        <li>HQL检索
                            <ul>
                                <li>概述: HQL(Hibernate Query Language)是面向对象的查询语言，在Hibernate检索方式中最广的一种，包含功能
                                    <ul>
                                        <li>在查询语句中设定查询条件</li>
                                        <li>支持投影查询，检索出对象的部分属性</li>
                                        <li>支持分页查询</li>
                                        <li>支持连接查询</li>
                                        <li>支持分组查询，允许使用HAVING和GROUP BY关键字</li>
                                        <li>提供内置聚集函数，如SUM(),MIN(),MAX()</li>
                                        <li>支持子查询</li>
                                        <li>支持动态绑定参数</li>
                                        <li>能够调用用户定义的sql函数或标准sql函数</li>
                                    </ul>
                                </li>
                                <li>HQL检索步骤
                                    <ul>
                                        <li>通过Session对象的createQuery()方法创建一个Query对象，包括一个HQL查询语句，HQL查询语句中包含命名参数</li>
                                        <li>调用绑定参数</li>
                                        <li>调用Query相关方法执行查询语句</li>
                                    </ul>
                                </li>
                                <li>Query接口支持方法链编程风格，它的setXxx()方法返回自身实例而不是void</li>
                                <li>HQL和SQL比较
                                    <ul>
                                        <li>
                                            HQL查询语句是面向对象的，Hibernate负责解析HQL查询语句，然后根据对象-关系映射文件中的映射信息，把HQL查询语句翻译成相关SQL语句，HQL查询语句的主体是域模型中类及类的属性
                                        </li>
                                        <li>SQL查询语句是与关系数据库绑定在一起的，SQL查询语句中的主体是数据库表及表的字段</li>
                                    </ul>
                                </li>
                                <li>绑定参数
                                    <ul>
                                        <li>Hibernate的参数绑定机制依赖于JDBC API中的PreparedStatement的预定义SQL语句功能</li>
                                        <li>HQL的参数绑定形式
                                            <br>按参数名字绑定：在HQL查询语句中定义命名参数，命名参数以":"开头
                                            <br>按参数位置绑定：在HQL查询语言中用"?"定义参数位置
                                        </li>
                                        <li>相关方法
                                            <br>setEntity() : 把参数与一个持久化类绑定
                                            <br>setParameter() : 绑定任意类型的参数，该方法的第三个参数显示指定Hibernate映射类型
                                        </li>
                                    </ul>
                                </li>
                                <li>排序：HQL采用ORDERBY关键字对查询结果进行排序</li>
                                <li>基本查询示例
                                    <img src="photo/hibernate/hibernate40.png" class="am-img-responsive">
                                </li>
                                <li>分页查询
                                    <ul>
                                        <li>setFirstResult(int firstResult)：设定从哪一个对象开始检索，参数firstResult表示这个对象在查询结果中的索引位置，所以位置的起始值为0，默认情况下，Query从查询结果中的第一个对象开始检索</li>
                                        <li>setMaxResults(int maxResults)：设定一次最多检索出的对象数目，默认情况下，Query和Criteria接口检索出查询结果中所有对象</li>
                                        <li>e.g.
                                            <pre>
@Test
public void testPageQuery() {
    String hql = "from Employee";
    Query query = session.createQuery(hql);
    int pageNo = 5;  //页数
    int pageSize = 20;  //每页显示数量
     //进行分页查询
    query.setFirstResult((pageNo-4) * pageSize)
        .setMaxResults(pageSize)
        .list();
    List&lt;Employee> employees = query.list();
    //显示对应的结果集
    for (int i = 0; i < employees.size(); ++i) {
        System.out.println(employees.get(i));
    }
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>命名查询：在映射文件中定义命名查询语句
                                    <ul>
                                        <li>Hibernate允许在映射文件中定义字符串形式的查询语句</li>
                                        <li>&lt;query>元素用于定义HQL查询语句，和&lt;class>位置并列</li>
                                        <li>在程序中通过Session的getNameQuery方法获取查询语句对应的Query对象</li>
                                        <li>e.g.
                                            <pre>
&lt;!-- 命名查询 -->
&lt;query name="salaryEmps">
    <![CDATA[from Employee e where e.salary > :minSal]]>
&lt;/query>
@Test
public void testNamedQuery() {
    Query query = session.getNamedQuery("salaryEmps");
    List&lt;Employee> employees = query.setFloat("minSal", 1000).list();
    System.out.println(employees.size());
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>投影查询
                                    <ul>
                                        <li>查询结果集仅包含实体的部分属性，通过select关键字实现</li>
                                        <li>Query的list()方法返回的集合中包含的是数组类型元素，每个对象数组代表查询结果的一条记录</li>
                                        <li>可以在持久化类中定义一个对象的构造器来包装投影查询的返回记录，是程序代码能完全运用面向对象的语义来访问查询结果集</li>
                                        <li>可以通过distinct关键字来保证查询结果不会返回重复元素</li>
                                        <li>e.g.1 结果集为数组类型的投影查询
                                            <pre>
@Test
public void testFieldQuery() {
    String hql = "select e.id, e.name from Employee e where e.department = :dept";
    Query query = session.createQuery(hql);
    Department department = new Department();
    department.setId(1);
    List<Object[]> result = query.setEntity("dept", department).list();
    for (Object [] objects : result) {
        System.out.println(Arrays.asList(objects));
    }
}</pre>
                                        </li>
                                        <li>e.g.2 结果集为对象类型的投影查询
                                            <pre>
@Test
public void testFileQuery2() {
    //结果集为对象类型的投影查询，需要在对应持久化类中加入无参构造器和对应参数构造器
    String hql = "select new Employee(e.id, e.name, e.department) from Employee e";
    Query query = session.createQuery(hql);
    List&lt;Employee> employees = query.list();
    for (Employee employee : employees) {
        System.out.println(employee.getId() + " - " + employee.getName());
    }
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>报表查询：对数据分组和统计
                                    <ul>
                                        <li>和SQL相同，HQL使用GROUP BY关键字对数据进行分组，用HAVING关键字对分组数据设定约束条件</li>
                                        <li>在HQL查询语句中可以调用的聚集函数 : count(), min(), max(), sum(), avg()</li>
                                        <li>e.g.
                                            <pre>
@Test
public void testGroupBy() {
    String hql = "select min(e.salary), max(e.salary) from Employee e"
            + " group by e.department having min(salary) > 500";
    Query query = session.createQuery(hql);
    List<Object[]> objects = query.list();
    for (Object[] obj : objects) {
        System.out.println(Arrays.asList(obj));
    }
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>HQL迫切左外连接
                                    <ul>
                                        <li>LEFT JOIN FETCH关键字表示迫切左外连接检索策略</li>
                                        <li>list()方法返回集合中存放实体对象的引用，每个查询的实体对象关联的对象集合都被初始化，存放其实体对象</li>
                                        <li>查询结果可能会包含重复元素，通过DISTINCT关键字或者HashSet过滤重复元素</li>
                                        <li>e.g.
                                            <pre>
@Test
public void testLeftJoinFetch() {
    String hql = "select distinct d from Department d left join fetch d.employees";
    Query query = session.createQuery(hql);
    List&lt;Department> departments = query.list();
    //可以通过包装List方式去重
    //departments= new ArrayList<>(new LinkedHashSet<>(departments));
    for (Department department : departments) {
    System.out.println(department.getEmployees().size());
    }
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>HQL左外连接
                                    <ul>
                                        <li>LEFT JOIN关键字表示左外连接查询</li>
                                        <li>list()方法返回的集合中存放的是对象数组类型</li>
                                        <li>根据配置文件来决定被关联对象的检索策略</li>
                                        <li>通过SELECT关键字将返回的集合类型从对象数组改为对象</li>
                                        <li>e.g.
                                            <pre>
@Test
public void testLeftJoin() {
    String hql = "select distinct d from Department d left join d.employees";
    Query query = session.createQuery(hql);
    List&lt;Department> departments = query.list();
    //不可以通过包装List方式去重
    //departments = new ArrayList<>(new LinkedHashSet<>(departments));
    for (Department department : departments) {
    System.out.println(department.getName());
    }
}</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>HQL迫切内连接
                                    <ul>
                                        <li>INNER JOIN FETCH关键字表示迫切内连接，INNER可以省略</li>
                                        <li>list()方法返回的集合中存放对象的引用，所有被关联的对象集合都被初始化，存放其关联对象实例</li>
                                        <li>e.g.
                                            <pre>
@Test
public void testInnerJoinFetch() {
    String hql = "select distinct d from Department d inner join fetch d.employees";
    Query query = session.createQuery(hql);
    List&lt;Department> departments = query.list();
    System.out.println(departments.size());
 }</pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>HQL内连接
                                    <ul>
                                        <li>INNER JOIN关键字表示内连接，INNER可以省略</li>
                                        <li>list()方法的集合中存放每隔元素对应查询结果的一条记录，每隔元素都是对象数组类型</li>
                                        <li>如果希望list()方法的返回集合仅包含对象，可以在HQL查询语句中使用SELECT关键字</li>
                                    </ul>
                                </li>
                                <li>HQL更新操作
                                    <br>
                                    <pre>
@Test
public void testHQLUpdate() {
    String hql = "delete from Employee e where e.id = :id";
    Query query = session.createQuery(hql);
    query.setInteger("id", 103).executeUpdate();
}</pre>
                                </li>
                                <li>关联级别运行时的检索策略
                                    <ul>
                                        <li>如果在HQL中没有显示指定检索策略，将使用映射文件中配置的检索策略</li>
                                        <li>HQL会忽略映射文件中设置的迫切左外连接检索策略，如果希望HQL采用迫切左外连接策略，必须在HQL查询语句中显式指定</li>
                                        <li>若在HQL代表中显式了检索策略，就会覆盖映射文件中配置的检索策略</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>QBC检索和本地SQL检索
                            <ul>
                                <li>QBC检索方式概述：QBC查询就是通过使用Hibernate提供的Query By Criteria
                                    API来查询对象，这种API封装的SQL语句的动态拼装，对查询提供了面向对象的功能接口
                                </li>
                                <li>QBC基本查询
                                    <pre>
@Test
public void testQBC() {
    //1. 创建一个Criteria对象
    Criteria criteria = session.createCriteria(Employee.class);
    //2. 添加查询条件：在QBC中查询条件使用Criterion来表示
    //        Criterion可以通过Restrictions的静态方法得到
    criteria.add(Restrictions.eq("name", "test20"));
    criteria.add(Restrictions.gt("salary", 500F));
    //3. 执行查询
    Employee employee = (Employee) criteria.uniqueResult();
    System.out.println(employee);
}</pre>
                                </li>
                                <li>QBC逻辑运算查询
                                    <pre>
@Test
public void testQBC2() {
    Criteria criteria = session.createCriteria(Employee.class);
    //1. AND : 使用Conjunction表示
    //        Conjuction本身就是一个Criterion对象
    Conjunction conjunction = Restrictions.conjunction();
    conjunction.add(Restrictions.like("name", "e", MatchMode.ANYWHERE));
    Department dept = new Department();
    dept.setId(50);
    conjunction.add(Restrictions.eq("department", dept));
    System.out.println(conjunction);
    //2. OR
    Disjunction disjunction = Restrictions.disjunction();
    disjunction.add(Restrictions.ge("salary", 500F));
    disjunction.add(Restrictions.isNull("name"));
    criteria.add(disjunction);
    criteria.add(conjunction);
    criteria.list();
}</pre>
                                </li>
                                <li>QBC统计查询
                                    <pre>
@Test
public void testQBC3() {
    Criteria criteria = session.createCriteria(Employee.class);
    //统计查询：使用Projection来表示,可以由Projections静态方法得到
    criteria.setProjection(Projections.max("salary"));
    System.out.println(criteria.uniqueResult());
}</pre>
                                </li>
                                <li>QBC排序查询
                                    <pre>
@Test
public void testQBC4() {
    //排序
    Criteria criteria = session.createCriteria(Employee.class);
    //1. 添加排序
    criteria.addOrder(Order.asc("salary"));
    criteria.addOrder(Order.desc("name"));
    //2. 添加分页方法
    int pageNo = 5;
    int pageSize = 20;
    List&lt;Employee> employees =
                criteria.setFirstResult((pageNo - 4) * pageSize)
                .setMaxResults(pageSize).list();
                System.out.println(employees.size());
}</pre>
                                </li>
                                <li>本地SQL检索
                                    <pre>
@Test
public void testNativeSQL() {
    String sql = "insert into employee(name, salary, dept_id) value(?,?,?)";
    Query query = session.createSQLQuery(sql);
    query.setString(0, "#test#")
        .setFloat(1, 6666).setInteger(2, 2).executeUpdate();
}</pre>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page9">3.2 缓存</h3>
                    <ol>
                        <li>缓存(Cache)
                            <ul>
                                <li>缓存介于应用程序和永久性数据存储源(如硬盘上的文件或者数据库)之间，其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能</li>
                                <li>Hibernate中提供两个级别的缓存
                                    <ul>
                                        <li>第一级别缓存：Session级别的缓存，属于事务范围的缓存，由Hibernate管理</li>
                                        <li>第二级别缓存：SessionFactory级别的缓存，属于进程范围的缓存</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>SessionFactory级别缓存分类
                            <ul>
                                <li>
                                    内置缓存：Hibernate自带，不可卸载，通常在Hibernate的初始化阶段，Hibernate会把映射元数据和预定义的SQL语句放到SessionFactory的缓存中，映射元数据是映射文件中数据(.hbm.xml文件中的数据)的复制，该内置缓存是只读的
                                </li>
                                <li>外置缓存(二级缓存)：一个可配置的缓存插件，在默认情况下SessionFactory不会启用这个缓存插件，外置缓存中的数据是数据库数据的复制，外置缓存的物理介质可以是内存或硬盘</li>
                            </ul>
                        </li>
                        <li>使用环境
                            <ul>
                                <li>适合放入二级缓存的数据
                                    <ul>
                                        <li>很少被修改的数据</li>
                                        <li>不是很重要的数据，允许偶尔出现并发问题</li>
                                    </ul>
                                </li>
                                <li>不适合放入二级缓存的数据
                                    <ul>
                                        <li>经常被修改的数据</li>
                                        <li>财务数据，绝对不允许出现并发问题</li>
                                        <li>与其他应用程序共享的程序</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>二级缓存并发访问策略
                            <ul>
                                <li>两个并发的事务同时访问持久层的缓存的相同数据时，也有可能出现各类并发问题</li>
                                <li>二级缓存可以设定4中类型的并发策略，每一种访问策略对应一种事务隔离级别
                                    <ul>
                                        <li>非严格读写(Nonstrict-read-write)：不保证缓存与数据库中的数据一致性，提供Read
                                            Uncommited事务隔离级别，对于极少被修改，允许脏读的数据可以采用这种策略
                                        </li>
                                        <li>读写型(Read-write)：提供Read Commited数据隔离级别，经常读但是很少被修改数据，可以采用这种隔离级别，可以防止脏读</li>
                                        <li>事务型(Transactional)：仅在受管理环境下适用，提供Repeatable
                                            Read事务隔离级别，对于经常读但很少修改的数据可以采用，可以防止脏读和不重复读
                                        </li>
                                        <li>只读型(Read-Only)：提供Serializable数据隔离级别，对于从来不会被修改的数据可以采用该访问策略</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>管理Hibernate二级缓存
                            <ul>
                                <li>Hibernate的二级缓存是进程或集群范围内的缓存</li>
                                <li>二级缓存是可配置的插件，Hibernate允许一下类型的缓存插件
                                    <ul>
                                        <li>EHCache - 可作为进程范围内的缓存,存放数据的物理介质可以使内存或硬盘,对Hibernate的查询缓存提供了支持</li>
                                        <li>OpenSymphony OSCache -
                                            可作为进程范围内的缓存,存放数据的物理介质可以使内存或硬盘,提供了丰富的缓存数据过期策略,对Hibernate的查询缓存提供了支持
                                        </li>
                                        <li>SwarmCache - 可作为集群范围内的缓存,但不支持Hibernate的查询缓存</li>
                                        <li>JBossCache - 可作为集群范围内的缓存,支持Hibernate的查询缓存</li>
                                    </ul>
                                </li>
                                <li>缓存插件支持的并发访问策略
                                    <img src="photo/hibernate/hibernate41.png" class="am-img-responsive">
                                </li>
                            </ul>
                        </li>
                        <li>配置Hibernate二级缓存步骤
                            <ul>
                                <li>加入二级缓存插件的jar包及配置文件
                                    <ul>
                                        <li>复制/hibernate-release.Final/lib/optional/ehcache/*.jar到当前Hibernate应用的类路径下
                                        </li>
                                        <li>复制/hibernate-release.Final/project/etc/ehcache.xml到当前WEB应用类路径下</li>
                                    </ul>
                                </li>
                                <li>配置hibernate.cfg.xml
                                    <ul>
                                        <li>配置启用hibernate的二级缓存
                                            <br><code>&lt;property name="cache.use_second_level_cache">true&lt;/property></code>
                                        </li>
                                        <li>配置hibernate二级缓存使用的产品
                                            <br><code>
                                                &lt;property name="hibernate.cache.region.factory_class"><br>
                                                org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property></code>
                                        </li>
                                        <li>配置使用二级缓存的类以及对应的缓存策略(也可以在.hbm.xml文件中配置)
                                            <br><code>
                                                &lt;class-cache usage="read-write" class="org.yang.demo.Employee"/><br>
                                                &lt;cache usage="read-write"/>(.hml.xml中配置)
                                            </code>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>类级别二级缓存
                            <pre>
@Test
public void testHibernateSecondLevelCache() {
    Employee employee = (Employee) session.get(Employee.class, 100);
    System.out.println(employee);
    transaction.commit();
    session.close();
    session = sessionFactory.openSession();
    transaction = session.beginTransaction();
    Employee employee2 = (Employee) session.get(Employee.class, 100);
    System.out.println(employee);
}
&lt;class-cache usage="read-write" class="org.yang.demo.Employee"/></pre>
                        </li>
                        <li>集合级别二级缓存
                            <pre>
@Test
public void testCollectionSecondLevalCache() {
    Department department = (Department) session.get(Department.class, 1);
    System.out.println(department.getName());
    System.out.println(department.getEmployees().size());
    transaction.commit();
    session.clear();
    session = sessionFactory.openSession();
    transaction = session.beginTransaction();
    Department department2 = (Department) session.get(Department.class, 1);
    System.out.println(department2.getName());
    System.out.println(department2.getEmployees().size());
}
&lt;class-cache usage="read-write" class="org.yang.demo.Employee"/>
&lt;class-cache usage="read-write" class="org.yang.demo.Department"/>
&lt;collection-cache usage="read-write" collection="org.yang.demo.Department.employees"/></pre>
                        </li>
                        <li>EHCache配置文件详解
                            <ul>
                                <li>&lt;diskStore> - 指定一个目录,当EHCache把数据写到硬盘上时,将把数据写到这个目录下</li>
                                <li>&lt;defaultCache> - 设置缓存的默认数据过期策略</li>
                                <li>&lt;cache> - 设定具体的命名缓存的数据过期策略,每个命名缓存代表一个缓存区域
                                    <ul>
                                        <li>缓存区域：一个具有名称的缓存缓存块，可以给每一个缓存块设置不同的缓存策略，如果没有指明缓存区域的使用默认策略</li>
                                        <li>Hibernate在不同的缓存区域保存不同的类/集合
                                            <ul>
                                                <li>对于类来说，区域的名称是全类名</li>
                                                <li>对于集合而言，去域名是全类名.属性名</li>
                                            </ul>
                                        </li>
                                        <li>cache元素属性
                                            <ul>
                                                <li>name : 设置缓存的名字,它的取值为类的全限定名或类的集合的名字</li>
                                                <li>maxInMemory : 设置基于内存的缓存中可存放的对象最大数目</li>
                                                <li>eternal : 设置对象是否为永久的,true表示永不过期,此时将忽略timeToIdleSeconds 和
                                                    timeToLiveSeconds属性; 默认值是false
                                                </li>
                                                <li>timeToIdleSeconds : 设置对象空闲最长时间,以秒为单位,
                                                    超过这个时间,对象过期。当对象过期时,EHCache会把它从缓存中清除。如果此值为0,表示对象可以无限期地处于空闲状态。
                                                </li>
                                                <li>timeToLiveSeconds :
                                                    设置对象生存最长时间,超过这个时间,对象过期。如果此值为0,表示对象可以无限期地存在于缓存中. 该属性值必须大于或等于
                                                    timeToIdleSeconds 属性值
                                                </li>
                                                <li>overflowToDisk : 设置基于内存的缓存中的对象数目达到上限后,是否把溢出的对象写到基于硬盘的缓存中 </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>查询缓存
                            <ul>
                                <li>默认情况下，设置查询缓存对HQL和QBC查询是无效的</li>
                                <li>开启查询缓存的方法
                                    <ul>
                                        <li>在hibernate配置文件中声明开启查询缓存
                                            <br><code>&lt;property name="cache.use_query_cache">true&lt;/property></code>
                                        </li>
                                        <li>调用Query或Criteria的setCacheAble(true)方法</li>
                                    </ul>
                                </li>
                                <li>查询缓存依赖二级缓存</li>
                                <li>e.g.
                                    <pre>
@Test
public void testQueryCache() {
    String hql = "from Employee";
    Query query = session.createQuery(hql);
    query.setCacheable(true);  //设置该查询允许被缓存
    List&lt;Employee> employees = query.list();
    System.out.println(employees.size());
    List&lt;Employee> employees2 = query.list();
        System.out.println(employees2.size());
}</pre>
                                </li>
                            </ul>
                        </li>
                        <li>时间戳缓存
                            <br>时间戳缓存区域存放了对于查询结果相关表进行插入，更新，删除操作的时间戳，Hibernate通过时间戳缓存区域来判断被缓存的查询结果是否过期，运行过程如下
                            <ul>
                                <li>T1时刻执行查询操作，把查询结果存放到QueryCache区域，记录该区域的时间戳为T1</li>
                                <li>T2时刻对查询结果相关的表进行更新操作，Hibernate把T2时刻存放在UpdateTimestampCache区域</li>
                                <li>T3时刻执行查询结果前，先比较QueryCache区域的时间戳和UpdateTimestampCache区域的查询结果，
                                    若T2 > T1，则丢弃原先存放在QueryCache区域的查询结果，重新导数据库中查询数据，
                                    若T2 < T1，则直接从QueryCache中获取查询结果</li>
                            </ul>
                        </li>
                        <li>Query接口iterator方法
                            <ul>
                                <li>Query接口的iterator方法
                                    <ul>
                                        <li>同list()一样执行查询操作</li>
                                        <li>list()方法执行的SQL语句包含实体类对应的数据表所有字段</li>
                                        <li>iterator()方法执行SQL语句中仅包含实体类对应数据表的ID字段</li>
                                        <li>当遍历访问结果集时，该方法先到Session缓存和二级缓存中查看是否存在特定的OID对象，如果存在直接返回，如果不存在就通过相应的SQL Select语句到数据库中加载特定的实体对象</li>
                                    </ul>
                                </li>
                                <li>大多数情况下使用list()方法执行查询操作，iterator()方法在查询表中包含大量字段和启用了二级缓存一集缓存中包含待查询对象的前提下可以稍微提高查询性能
                                </li>
                                <li>e.g.
                                    <pre>
@Test
public void testQueryIterate() {
    Department department = (Department) session.get(Department.class, 4);
    System.out.println(department.getName());
    System.out.println(department.getEmployees().size());
    Query query = session.createQuery("from Employee e where e.department = 4");
//  List&lt;Employee> employees = query.list();
//  System.out.println(employees);
Iterator&lt;Employee> emIterator = query.iterate();
    while (emIterator.hasNext()) {
    System.out.println(emIterator.next().getName());
    }
}</pre>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page10">3.3 管理Session</h3>
                    <ol>
                        <li>Hibernate提供了3种方式管理Session对象
                            <ul>
                                <li>Session对象的生命周期与本地线程绑定</li>
                                <li>Session对象的生命周期与JTA事务绑定</li>
                                <li>Hibernate委托程序管理Session对象的生命周期</li>
                            </ul>
                        </li>
                        <li>配置管理Session方式
                            <ul>
                                <li>在.cfg.xml中的hibernate.current_session_context_class属性用于指定Session管理方式，可选值:
                                    <ul>
                                        <li>thread - Session对象的生命周期与本地线程绑定</li>
                                        <li>jta - Session对象的生命周期与JTA事务绑定</li>
                                        <li>managed - Hibernate委托程序来管理Session对象的生命周期</li>
                                    </ul>
                                </li>
                                <li>e.g.
                                    <br><code>&lt;property name="current_session_context_class">thread&lt;/property></code>
                                </li>
                            </ul>
                        </li>
                        <li>Session对象的生命周期与本地线程绑定
                            <ul>
                                <li>
                                    当一个线程(threadA)第一次调用SessionFactory对象的getCurrentSession()方法时，该方法会创建一个新的Session(SessionA)对象，把该对象与threadA绑定，并返回sessionA
                                </li>
                                <li>当threadA再次调用sessionFactory对象的getCurrentSession方法时，该方法将返回sessionA对象</li>
                                <li>当threadA提交sessionA对象关联事务时，Hibernate会自动flush
                                    sessionA对象的缓存，然后提交事务，关闭sessionA对象；当threadA撤销sessionA对象关联的事务时也会自动关闭sessionA对象
                                </li>
                                <li>
                                    当threadA再次调用sessionFactory对象的getCurrentSession()方法时，该方法会创建一个新的Session(sessionB)对象，并将该对象与threadA绑定，返回sessionB
                                </li>
                                <li>e.g.
                                    <pre>
public class HibernateUtils {
    private static HibernateUtils instance = new HibernateUtils();
    public static HibernateUtils getInstance() {
        return instance;
    }
    private SessionFactory sessionFactory;
    public SessionFactory getSessionFactory() {
        if (sessionFactory == null) {
            Configuration configuration = new Configuration().configure();
            ServiceRegistry serviceRegistry = new ServiceRegistryBuilder()
                    .applySettings(configuration.getProperties()).buildServiceRegistry();
            sessionFactory = configuration.buildSessionFactory(serviceRegistry);
        }
        return sessionFactory;
    }
    public Session getSession() {
        return getSessionFactory().getCurrentSession();
    }
}
public class DepartmentDao {
    /**
     * 若需要传入一个Session对象，则意味着上一层(Service)需要获取到Session对象
     * 说明上一层需要和Hibernate API耦合，不推荐使用传入Session对象的方法
     * @param session
     * @param department
     */
    public void save(Session session, Department department) {
        session.save(department);
    }
    public void save(Department department) {
        //内部获取Session对象
        //获取和当前线程绑定的Session对象
        //        1. 不需要外部传入session对象
        //        2. 多个DAO方法可以使用一个事务
        Session session = HibernateUtils.getInstance().getSession();
        System.out.println(session.hashCode());
        session.save(department);
    }
}
@Test
public void testManageSession() {
    Session session = HibernateUtils.getInstance().getSession();
    System.out.println("-->" +session.hashCode());
    Transaction transaction = session.beginTransaction();
    DepartmentDao departmentDao = new DepartmentDao();
    Department department = new Department();
    department.setName("testManageSession");
    departmentDao.save(department);
    transaction.commit();
    System.out.println(session.isOpen());
}</pre>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <h3 id="page11">3.4 批量处理数据</h3>
                    <ol>
                        <li>批量处理数据指的是在一个事务中处理大量数据</li>
                        <li>在应用层进行批量操作，主要有4种方式：通过Session, 通过HQL, 通过StatelessSession, 通过JDBC API</li>
                        <li>推荐使用原生JDBC API进行批量操作
                            <pre>
@Test
public void testBatch() {
    session.doWork(new Work() {
        @Override
        public void execute(Connection connection) throws SQLException {
            //通过JDBC原生API操作效率最高，速度最快
        }
    });
}</pre>
                        </li>
                        <li>通过Session进行批量操作
                            <ul>
                                <li>
                                    Session的save()及update()方法会把处理的对象放入缓存中，如果通过Session对象处理大量持久化对象，应该及时从缓存中清空已处理完毕且不会再被访问的对象
                                </li>
                                <li>具体做法：在处理完一个对象或者一小批对象后，立即调用flush()方法刷新缓存，然后调用clear()方法清空缓存</li>
                                <li>通过Session来处理批量数据收到的约束
                                    <ul>
                                        <li>需要在Hibernate配置文件中设置JDBC单次批量处理的数目，应保证每次向数据库发送批量的SQL语句与batch_size属性相一致</li>
                                        <li>若对象采用"identity"标识符生成器，则Hibernate无法在JDBC层进行批量插入操作</li>
                                        <li>进行批量操作时，建议关闭二级缓存</li>
                                    </ul>
                                </li>
                                <li>e.g.1 批量插入
                                    <pre>
News news = new News();
for (int i = 0; i < 1000000; ++i) {
    news = new News();
    news.setTitle("title : " + i);
    session.save(news);
    if ((i + 1) % 20 == 0) {
        session.flush();
        session.clear();
    }
}</pre>
                                </li>
                                <li>批量更新方法：使用可滚动的结果集org.hibernate.ScrollableResults，该对象中实际不包含任何对象
                                    ，只包含用于在线定位记录的游标，只有当程序遍历访问ScrollableResults对象的待定元素时，
                                    才会到数据库中加载相应的对象；org.hibernate.ScrollableResults对象由Query的scroll方法返回</li>
                                <li>e.g.2 批量更新
                                    <pre>
ScrollableResults sr = session.createQuery("from News").scroll();
int count = 0;
while (sr.next()) {
    News n = (News) sr.get(0);
    n.setTitle("test");
}
if (((count++) + 1) % 100 == 0) {
    session.flush();
    session.clear();
}</pre>
                                </li>
                            </ul>
                        </li>
                        <li>通过HQL批量操作：HQL只支持INSERT INTO ... SELECT形式的插入，不支持INSERT INTO VALUES形式的插入语句</li>
                        <li>通过StatelessSession批量操作
                            <ul>
                                <li>形式上StatelessSession与session用法类似</li>
                                <li>StatelessSession与Session的区别：
                                    <ul>
                                        <li>StatelessSession没有缓存，通过StatelessSession来加载，保存，更新后的对象处于游离对象</li>
                                        <li>StatelessSession不会与Hibernate二级缓存产生交互</li>
                                        <li>当调用StatelessSession的save(), update(), delete()方法时,这些方法会立即调用相应的sql语句，不会仅计划执行一条语句</li>
                                        <li>StatelessSession不会对关联的对象两次进行任何级联操作</li>
                                        <li>StatelessSession不会进行脏数据检查，因此修改对象属性后需要手动调用StatelessSession的update()方法进行更新</li>
                                        <li>通过一个StatelessSession对象两次加载OID相同的对象，得到的两个对象地址不同</li>
                                        <li>StatelessSession所做的操作可以被Interceptor拦截器捕获到，但会被Hibernate的事件处理系统忽略</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <!--文章]]-->
                </div>
            </div>
        </div>
    </div>
    <div class="am-u-md-3 am-u-md-pull-9 my-sidebar" id="pageDesc">
        <div class="am-offcanvas" id="sidebar" data-am-sticky="{top:51}">
            <div class="am-offcanvas-bar">

                <ul class="am-nav">
                    <h1>Hibernate</h1>
                    <!--导航[[-->
                    <li class="am-nav-header">基础知识</li>
                    <li><a href="#!" id="btn1">对象持久化与ORM</a></li>
                    <li><a href="#!" id="btn2">Hibernate开发步骤</a></li>
                    <li><a href="#!" id="btn3">基本配置</a></li>
                    <li><a href="#!" id="btn4">Session & CRUD</a></li>
                    <li class="am-nav-header">映射</li>
                    <li><a href="#!" id="btn5">类与表的映射</a></li>
                    <li><a href="#!" id="btn6">映射关联关系</a></li>
                    <li><a href="#!" id="btn7">继承映射</a></li>
                    <li class="am-nav-header">更多操作</li>
                    <li><a href="#!" id="btn8">检索</a></li>
                    <li><a href="#!" id="btn9">缓存</a></li>
                    <li><a href="#!" id="btn10">管理Session</a></li>
                    <li><a href="#!" id="btn11">批量处理数据</a></li>

                </ul>
                <!--导航]]-->
            </div>
        </div>
    </div>
    <!--<a href="#sidebar" class="am-btn am-btn-sm am-btn-success am-icon-bars am-show-sm-only my-button"
        data-am-offcanvas style="background-color: rgb(248,248,248); margin: 6px; border: 0; color: #666; font-size: 20px; z-index: 999;"><span class="am-sr-only">侧栏导航</span></a>-->
</div>

<!--页脚[[-->
<br><br><br>
<div class="am-g">
    <div class="am-u-lg-10 am-u-lg-offset-1" id="footer">
        <br>
        <span class="am-fl">Copyright © 2016-2017 yangyuhao</span>
        <span class="am-fr">联系我： QQ:1101632336 | Email:isyangyuhao@gmail.com | <a href="http://github.com/isyangyuhao">GitHub</a></span>
    </div>
</div>
<br><br><br>
<!--页脚]]-->

<!--[if lt IE 9]>
<script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
<script src="http://cdn.staticfile.org/modernizr/2.8.3/modernizr.js"></script>
<script src="assets/js/amazeui.ie8polyfill.min.js"></script>
<![endif]-->

<!--[if (gte IE 9)|!(IE)]><!-->
<script src="assets/js/jquery.min.js"></script>
<!--<![endif]-->
<script src="assets/js/amazeui.min.js"></script>
<script type="text/javascript">
    //加载进度条
    var progress = $.AMUI.progress;
    $(window).load(function() {
        progress.done();
    })
    $(document).ready(function() {
        progress.start();
    })
    //侧边栏平滑滚动
    $(window).smoothScroll();
    function navClick($btnObj, $pageObj) {
        $btnObj.on("click", function() {
            var $w = $(window);
            $w.smoothScroll({position: $pageObj.offset().top});
        })
    }
    navClick($("#btn1"), $("#page1"));
    navClick($("#btn2"), $("#page2"));
    navClick($("#btn3"), $("#page3"));
    navClick($("#btn4"), $("#page4"));
    navClick($("#btn5"), $("#page5"));
    navClick($("#btn6"), $("#page6"));
    navClick($("#btn7"), $("#page7"));
    navClick($("#btn8"), $("#page8"));
    navClick($("#btn9"), $("#page9"));
    navClick($("#btn10"), $("#page10"));
    navClick($("#btn11"), $("#page11"));

</script>
</body>
</html>
